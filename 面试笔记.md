# 项目

## 璇玑系统

1. 场景：一个co-table表格，（对KwaiUI表格的封装，采用配置的方式展示表格，并提供常用的各种数据格式的展示。 对于非props的其他属性，都会透传给KwaiUI的table组件。），对于表格内的元素，需要做一个气泡窗的效果，对于每行的元素渲染是写了一个getTableColums函数，返回一个数组，渲染每行的内容。数组每个元素是一个对象：有label、key、props和render属性。在render属性对应一个函数，会用到h渲染函数，h渲染函数用来创建虚拟 DOM 节点 (vnode)。所以render返回值是VNode（虚拟节点），类型可以是String 、Array；

   h函数有三个参数：第一个是字符串也可以是一个Vue自定义组件，第二个参数是要传递的prop，第三个参数是子节点。

   封装tooltip组件，render函数

   

   template和render的区别：

   template----html的方式做渲染,template也是一种编译方式，但是template最终还是要通过render的方式再次进行编译

   [render](https://so.csdn.net/so/search?q=render&spm=1001.2101.3001.7020)----js的方式做渲染

   1、render渲染方式可以让我们将js发挥到极致，因为render的方式其实是通过createElement()进行虚拟DOM的创建。逻辑性比较强，适合复杂的组件封装。

   2、template是类似于html一样的模板来进行组件的封装。

   3、render的性能比template的性能好很多

   4、render函数优先级大于template

   ```css
   overflow: hidden;
   text-overflow: ellipsis;
   white-space: nowrap;
   ```

   

   ![image-20220930101230159](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220930101230159.png)

2. 级联选项，返回树状结构中，子选项为空数组时的处理

   ```js
   export interface TreeNode {
       children: TreeNode[] | null;
       [key: string]: any;
   }
   
   export type Children = TreeNode["children"];
   
   export type FilterNode = (node: TreeNode) => boolean;
   
   function isNotEmpty(children: Children): boolean {
       return Array.isArray(children) && children.length > 0;
   }
   
   export function parseTreeData(
       treeData: TreeNode[] = [],
       filterNode: FilterNode
   ): TreeNode[]{
       if (treeData.length === 0) {
           return treeData;
       }
       function travel(list: TreeNode[]): Children {
           const array = [];
           const len = list.length;
           for (let i = 0; i < len; i++) {
               const node = list[i];
               const children = node["children"];
               const cloneData = {
                   ...node,
                   children: isNotEmpty(children) ? travel(children!) : children,
               }
               if (filterNode) {
                   if (filterNode(node)) {
                       array.push(cloneData);
                   }
               } else {
                   array.push(cloneData);
               }
           }
           return array.length > 0 ? array : null;
       }
       const ret =  travel(treeData);
       return ret === null ? [] : ret;
   }
   
   ```

3. 新申诉功能

   批量申诉功能：

   自己勾选和全选（获取当前用户的最大粉丝号）

   **问题**：

   - 当取消勾选的时候，用户数量没有变化

     **解决**：在isCheck不为true时，将用户信息从checkMap中删除

     delete this.checkInfoMap[basicInfo.polarisUserId];

   - 多个快手用户是，每点一次申诉，会增加非账号数字

     **解决：**每次调用函数前先将authorList置空，

     ```js
     this.appealModel.authorList = [];
             platformInfo.forEach(item => {
                 if (item.platformType * 1 === 1) {
                     this.appealModel.authorList.push([
                         item.identity,
                         item.fanCount,
                     ]);
                 }
             });
             this.appealModel.authorList.sort((a, b) => b[1] - a[1]);
             this.appealModel.authorList = this.appealModel.authorList.map(
                 item => {
                     return item[0];
                 },
             );
     ```

     ![image-20220915021152240](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220915021152240.png)

4. **前端性能优化：**

   目的：

   - 减少资源请求；
   - 提高用户体验。

   方法：

   webpack方面：

   1. **构建时间优化：**

      - **thread-loader**：

        多进程打包，可以大大提高构建的速度，使用方法是将`thread-loader`放在比较费时间的loader之前，放置在这个 loader 之后的 loader，就会在一个单独的 worker 池(worker pool)中运行

      - **cache-loader**

        缓存资源，提高二次构建的速度，使用方法是将`cache-loader`放在比较费时间的loader之前

      - **开启热更新**

        比如你修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间

      - exclude & include

   2. **打包体积优化**

      - **CSS代码压缩**

        CSS代码压缩使用`css-minimizer-webpack-plugin`，效果包括压缩、去重

        > 代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在`webpack.prod.js`中配置

      - **JS代码压缩**

        JS代码压缩使用`terser-webpack-plugin`，实现打包后JS代码的压缩

      - **tree-shaking**

        `tree-shaking`简单说作用就是：只打包用到的代码，没用到的代码不打包，而`webpack5`默认开启`tree-shaking`，当打包的`mode`为`production`时，自动开启`tree-shaking`进行优化

        打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率

      - **打包体积分析**

        使用`webpack-bundle-analyzer`可以审查打包后的体积分布，进而进行相应的体积优化

        ```js
        const {
          BundleAnalyzerPlugin
        } = require('webpack-bundle-analyzer')
        
          plugins: [
            new BundleAnalyzerPlugin(),
        ]
        ```

   3. 用户体验优化

      - **模块懒加载**

        使用`模块懒加载`之后，大js文件会分成多个小js文件，网页加载时会按需加载，大大提升首屏加载速度

        ```js
        component: () => import('../views/home/home.vue'),
        ```

      - **小图片转base64**

        对于一些小图片，可以转base64，这样可以减少用户的http网络请求次数，提高用户的体验

        ```js
        {
           test: /\.(png|jpe?g|gif|svg|webp)$/,
           type: 'asset',
           parser: {
             // 转base64的条件
             dataUrlCondition: {
                maxSize: 25 * 1024, // 25kb
             }
           },
           generator: {
             // 打包到 image 文件下
            filename: 'images/[contenthash][ext][query]',
           },
        }
        ```

      - **合理配置hash**

        改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样才能保证在上线后，浏览器访问时没有改变的文件会命中缓存，从而达到性能优化的目的

        ```js
        //webpack.web.js  
        output: {
            path: path.resolve(__dirname, '../dist'),
            // 给js文件加上 contenthash，文件名
            filename: 'js/chunk-[contenthash].js',
            clean: true,
          },
        
        ```

        

   - 减少资源请求：减少http请求，合并&压缩资源，图片优化，网络优化等；

   - 提高用户体验：在不影响当前业务的基础上，通过对现有代码的优化，提升前端加载性能和用户交互体验，例如: 加载时间变短, 页面操作更加的流畅。

     params 是当前组件中定义的一个data属性。 也就是说，如果实验有返回的数据超过·20000条，这20000条的数据就都变成响应式了。 而这些响应式的数据在被赋值以后，会触发对应的相关依赖的callback。而Vue的dom更新要在这些依赖的callback执行之后。对于用户感知而言，就是页面卡顿。

     在当前业务的代码中，由于业务中靠全量参数(params)生成的依赖比较多，而且是大部分都是通过computed(底层也是watch)和watch生成。这里就考虑到一个问题，这些依赖项是否需要与全量参数(params)  同步。 经过分析，发现很多的些依赖可以不需要与全量参数同步，可以改成在用户交互的时候在获取相关的数据。

     将computed依赖换成methods方法，这样就隔离了 params 与 paramNames依赖 的同步，等到用户点击下拉选项的时候，再去获取对应的参数名称就行。

5. 埋点知识

   **PV事件**

   weblog.sendImmediately('PV', {
       type: '**enter**',
       page: 'TEST_PAGE', // 设置当前进入页面的页面标识（在埋点平台注册，在 App 分析查看）
       params: {//页面补充参数，需在埋点管理平台注册
           name: 'test'
       },
       contentPackage: {//业务补充参数，特定业务需求
           traceId: 123
       }
   });
   // 触发 leave 事件
   weblog.sendImmediately('PV', {
       type: '**leave**',
       // 传入 enter 时的 beginTime，会上报停留时长
       beginTime: beginTime
   });

   

6. 运行一个项目如何发现没有内存泄漏？

## radio组件

radio-group和radio之间的组件通信原理：

radio-group：

```js
<template>
    <!-- radio-group, 有radio子组件
        父组件会传递过来一个v-model即value和input事件
        radio-group组件要把该value值传递给子组件radio
        子组件radio中该值发生变化，要通知radio-group，radio-group再通过input事件通知父组件
        如何把value值双向绑定给子组件呢？--
        element-ui 2.15.1 通过组件radio向上追溯判断父组件是否是radio-group, 如果是的话, 则取radio-group的value值
     -->
    <div class="y-radio-group" role="rolegroup">
        <!-- 并没有给子组件传递方法更新value值，那么子组件radio是如何通知父组件radio-group更新呢？(使用混入mixins的dispatch方法向上冒泡) -->
        <slot></slot>
    </div>
</template>

<script>
export default {
    name: 'YRadioGroup',
    componentName: 'YRadioGroup',
    props: {
        value: {},
    },
    created() {
        /**
         * this.$on 监听当前实例上的自定义事件。
         * 事件可以由 this.$emit 触发。
         * 回调函数会接收所有传入事件触发函数的额外参数。
         * 事实上, 子组件radio在调用的父组件radio-group的handleChange方法, 在radio-group没有显示定义
         */
        this.$on('handleChange', value => {
            console.log('radio-group监听handleChange发生了变化', value);
            // 通知父组件更新双向绑定的值
            this.$emit('input', value);
        })
    },
    mounted() {
        console.log('变化了', this.value, this.$slots);
    }
}
</script>
```

子组件：

1. 向上追溯父组件是否为radio-group，通过isGroup事件来判断，如果是返回true；

2. 如果是父组件下的radio，则model走get()方法取radio-group组件上的value；

3. 子组件radio值发生变化，会触发input上面绑定的handleChange事件，通过混入Emitter，会触发dispatch('YRadioGroup', 'handleChange', this.model)方法，调用父组件的handelChange事件，更新model值；model触发set()方法，通过混入Emitter，调用了dispatch方法，通知父组件radio-group更新，然后同步到原生单选框的选中状态

   ```js
    // 混入，增加dispath方法，将事件向上派发给父组件
       mixins: [Emitter],
   // 接收父组件传递的数据
       props: {
           value: {}, // 父组件v-model
           label: {}, // 父组件label
       },
       
       computed: {
           
           // 向上追溯父组件是否为radio-group，（不能通过name来判断，所以需要在radio-group定义componentName）
           isGroup() {
               let parent = this.$parent;
               while(parent) {
                   // console.log('radio下的父组件', parent, parent.$options.componentName);
                   if(parent.$options.componentName !== 'YRadioGroup') {
                       parent = parent.$parent;
                   }else {
                       // 保留radio-group组件的数据
                       this._radioGroup = parent;
                       return true;
                   }
               }
               return false;
           },
           
           /**
            * 如果是父组件radio-group下的radio, 则isGroup为true, model取radio-group组件上的value
            * 如何去通知父组件radio-group更新value值呢？
            */
           model: {
               get() {
                   // return this.value;
                   return this.isGroup ? this._radioGroup.value : this.value;
               },
               set(val) {
                   console.log('model值发生了变化', val);
                   // 通知父组件更新v-model对应的value值
                   // this.$emit('input', val)
                   if(this.isGroup) {
                       // this.dispatch('YRadioGroup', 'input', [val]);
                       // this.dispatch 是混入进来的, 通知父组件radio-group更新
                       this.dispatch('YRadioGroup', 'input', [val]);
                   }else {
                       this.$emit('input', val);
                   }
                   // 同步到原生单选框的选中状态
                   this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);
               }
           }
       },
           
        methods: {
           handleChange() {
               // input改变后, 需要等视图的更新, 更新后方可获取该值, 为label对应的值
               this.$nextTick(()=>{
                   console.log('handleChange', this.model);
                   // 这句话有什么意义, 通知父组件选中状态变化后的回调
                   this.$emit('change', this.model);
                   // 如果是父组件是radio-group组件, 则调用父组件的handleChange, 以更新model值
                   this.isGroup && this.dispatch('YRadioGroup', 'handleChange', this.model);
               })
           },
       },
   
   ```

   

## 微前端

### single-spa原理：

![image-20221103141230017](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221103141230017.png)

1. 应用注册（registerApplication）
   - 应用注册方法主要是对子应用参数进行格式化后，将子应用放入应用列表中，并把应用状态初始化为`NOT_LOADED`
2. 基座应用启动(start)
   - 这里比较简单，只需要对基座唯一状态值进行更改
3. 更新应用相关(reroute)
   - reroute方法是对更改所有需要更改的应用状态，并执行对应操作（该挂载的挂载，该卸载的卸载，改为他应该处在的状态）,其实就是url改变后需要做的操作。
4. 路由监听
   - 截止目前，我们已经做好了所有应用的相关操作：子应用的加载、以及路由变化后所做的挂载、卸载等，还剩下最后一步路由的监听，只有监听了路由的改变，我们的single-spa才能对子应用执行相应的操作



线上微前端运行的主要方式是，首先加载Master App的html和js&css资源，然后根据不同路由去加载对应Slave App的json描述，最后根据描述的内容去加载子应用的js&css并渲染到指定节点，注意Master和Slave的开发和部署是独立的。

**主子应用本地模式下如何配合开发**：在该模式下，Master在访问Slave时，通过local server提供的proxy能力，让Master在访问子应用的配置时（如/app1/assets.json，/app2/assets.json）代理到各个子应用的local server服务上，使Master能正确加载各个Slave的配置，最终完成主子应用的配合开发。

子应用的入口文件(micro-frontends.ts)中，引入singleSpaVue方法，将本地开发的vue项目变成微应用的项目，并且导出一些方法供主应用调用，比如mount，unmount方法等。

思考：

1. 在开发中，由于之前没有接触过这一块的内容，所以在开始搭建项目时，在纠结直接使用前辈的模板搭建，然后在安装vue3版本下的各个依赖，但是发现这样会卸载大量模板下的依赖，比较麻烦；最后确定先搭建vue3+vite的初始项目，后面根据引用组件安装各个依赖。所以在开始前，需要考虑版本升级后，原来的方法是否还适用，是否可以直接套用，根据现在的需求找到适用方法。
2. 在查阅资料时，考虑到会有样式冲突问题（子应用之间的冲突和主子应用之间的冲突）、各个子应用之间会有应用通信问题、js隔离等问题，在迁移项目的时候可以考虑怎样解决这些问题，比如样式冲突问题，我们可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰。
3. 在对配置文件进行修改时，通过对比线上的子应用vue.config.js文件，考虑在配置时，我们需要思考以下方面，比如配置别名alias、生产环境下使用Sentry收集线上错误信息并进行定位、不同环境配置文件入口不同、不同入口文件的写法等等。

缺点：

- 从上图可以看出，基座在匹配到路径时候需要手动的添加js，如果子项目打包出一万个js，那....
- 样式不隔离
- 没有js沙箱的机制

### 沙箱机制

参考https://weibo.com/ttarticle/p/show?id=2309634791254629351969

- 基于proxy的沙箱机制

  - 支持子应用单实例沙箱（LegacySandbox）

    LegacySandbox 的思路在于虽然建立了沙箱代理，但在子应用运行过程中，所有的赋值仍旧会直接操作 window 对象，代理所做的事情就是记录变化（形成快照）；而针对激活和卸载，沙箱会在激活时还原子应用的状态，而卸载时还原主应用的状态，以此达到沙箱隔离的目的。

  - 支持子应用多实例沙箱（ProxySandbox）

    用 Proxy 给子应用运行环境做了 get 与 set 拦截。沙箱在初始构造时建立一个状态池，当应用操作 window 时，赋值通过 set 拦截器将变量写入状态池，而取值也是从状态池中优先寻找对应属性。由于状态池与子应用绑定，那么运行多个子应用，便可以产生多个相互独立的沙箱环境。

- 基于属性 diff 的沙箱机制

- 基于iframe实现沙箱

  iframe 标签可以创造一个独立的浏览器级别的运行环境，该环境与主环境隔离，并有自己的 window 上下文；在通信机制上，也可以利用 postMessage 等 API 与宿主环境进行通信。

  - 应用间运行时隔离：在 iframe 中运行的 JavaScript 代码都是直接操作 iframe 的 window 上下文；
  - 应用间通信；
  - 路由劫持；

  

## 长列表渲染

虚拟列表实际上就是一种按需渲染的操作。我们在渲染上万条数据时，只需要渲染可视区当中的元素，当页面发生滚动时，监听元素并进行替换，从而达到在上万上亿条数据面前，被页面渲染的也只有不过几百个节点，达到优化长列表大数据渲染的目的。

## 大文件上传

## 一键换肤



## 登录流程

前端 ，输入用户名和密码，验证通过后，点击登录，后端收到请求，验证用户名和密码，正确后，给前端返回token、用户信息，和200状态码，前端拿到token和用户信息后保存到vuex中，把用户信息再存储到localStroage中。之后在前端每次发送请求时通过给请求头header属性Authorization中设置：Bearer + " " + token，让每次请求都携带token，后端判断请求头中token是否过期，过期会返回一个过期的状态码，前端通过响应拦截interceptors.response.use()显示错误信息并且跳转到登录页面重新登录。



## 轮询

### 短轮询

- 基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。
- 这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。

### **WebSocket`双工通信`**

- WebSocket是Html5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。
- WebSocket的优点是实现了双向通信，缺点是兼容性差，服务器端的逻辑非常复杂。现在针对不同的后台语言有不同的插件可以使用。



https://juejin.cn/post/7020964728386093093

h5提供的一种浏览器与服务器进行**全双工通信**的网络技术，属于**应用层**协议。

1. 单向通信/单工通信：只能由一个方向的通信而没有反方向的交互
2. 双向交替通信/半双工通信：通信双发都可以发送信息，但不能双方同时发送
3. 双向同时通信/**全双工通信**：通信双发可以同时发送和接收信息

特点：

（1）**建立在 TCP 协议之上**，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）**可以发送文本，也可以发送二进制数据。**

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

一些api：

- webSocket.onopen：连接成功后的回调函数
- webSocket.onclose：用于指定连接关闭后的回调函数
- webSocket.onmessage:用于指定收到服务器数据后的回调函数
- webSocket.send():用于向服务器发送数据

#### 原理

具体实现是通过http协议建立通道，然后再此基础上使用websocket协议进行通信。

过程：

客户端发起http请求，经过三次握手之后，建立起tcp链接，http请求里存放websocket支持的版本号信息，如：Upgrade、Connection、WebSocket-Version等；然后，服务器收到客户端的握手请求后，同样采用http协议反馈数据，最后，客户端收到连接成功的消息后，开始借助于tcp传输信道进行全双工通信。

#### 断线重连

当客户端第一次发请求至服务端时会携带唯一标识，以及时间戳，服务端到db或者缓存去查询该请求的唯一标识，如果不存在就存入db或者缓存中

第二次客户端定时再次发送请求依旧携带唯一标识，以及时间戳，服务端到db或者缓存中去查询该请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前的时间戳减去上次的时间，得出的毫秒数判断是否大于指定的时间，小于的话就是在线，否则就是离线

断线原因：

- websocket超时没有消息自动断开连接
- websocket异常包括服务端出现中断，交互切屏等等客户端异常中断等等
  - 解决方法:引入reconnecting-websocket.min.js

**解决：**

- 修改nginx配置信息
- websocket发送心跳包
  - 客户端每隔一个时间间隔发生一个探测包给服务器
  - 客户端发包时启动一个超时定时器
  - 服务器端接收到检测包，应该回应一个包
  - 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
  - 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了





# HTML

## DOCTYPE

向浏览器说明以哪种规范解析HTML。一种是标准模式：以浏览器最高版本解析。一种是混杂模式：以一种宽松的向后兼容的模式解析文档。宽松向后兼容的模式怎么触发：没写DOCTYPE或者格式不正确。

## 盒模型

标准盒模型和IE盒模型，可以通过box-sizing属性来切换盒模型，content-box为标准盒模型，border-box为怪异盒模型

**标准盒模型**：只包含内容content，不包含border和padding

**IE盒模型**：width包含content、padding和border

应用：让子容器并排充满父容器，一切想的挺美好，然而你发现结果并不是这么美好，因为子容器的盒子宽度已经超出了父容器的一半，导致了折行，于是，width就不能50%了，只能是50%再减去padding的像素值，设为border-box之后，padding和border的厚度可以随意调，并不会溢出父元素。如果是content-box，那么，宽度必然会溢出，而且，为了不溢出，你设定子元素的宽度就只能是一个定值，或者是一个计算值（比如calc(100% - 20px)

## meta标签

head标签中有什么：<title>、<base>、<link>、<style>、<meta>、<script>

<meta>

`meta`网页能否被搜索引擎检索，和在搜索中的排名起着关键性的作用。

**content**用于表示需要设置的项的值

meta存在两个非必须的属性**http-equiv**和**name**

### http-equiv属性

`http-equiv`一般设置的都是与`http`请求头相关的信息，设置的值会关联到http头部。浏览器在请求服务器获取`html`的时候，服务器会将`html`中设置的`meta`放在响应头中返回给浏览器。常见的类型比如`content-type`, `expires`, `refresh`, `set-cookie`, `window-target`, `charset`， `pragma`等等。

1. content-type

```js
用来声明文档类型、设字符集，目前`content-type`只能在html文档中使用。

content-type: text/html charset=utf8
```

	2. expires

```js
用于设置浏览器的过期时间, 其实就是响应头中的expires属性。

<meta http-equiv="expires" content="31 Dec 2021">
```

3. refresh

```js
该种设定表示5秒自动刷新并且跳转到指定的网页。如果不设置url的值那么浏览器则刷新本网页。

<meta http-equiv="refresh" content="5 url=http://www.zhiqianduan.com">
```

4. window-target

```js
强制页面在当前窗口以独立页面显示, 可以防止别人在框架中调用自己的页面。

<meta http-equiv="window-target" content="_top'>
```

5. pragma

```js
禁止浏览器从本地计算机的缓存中访问页面的内容

<meta http-equiv="pragma" content="no-cache">
```

### name属性

`name`属性主要用于描述网页，与对应的`content`中的内容主要是便于搜索引擎查找信息和分类信息用的

1. author

```js
author用来标注网页的作者

<meta name="author" content="aaa@mail.abc.com">
```

2. description

```js
description用来告诉搜素引擎当前网页的主要内容，是关于网站的一段描述信息。

<meta name="description" content="这是我的HTML">
```

3. keywords

```js
keywords设置网页的关键字，来告诉浏览器关键字是什么。是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。

<meta name="keywords" content="Hello world">
```

4. generator

```js
表示当前html是用什么工具编写生成的，并没有实际作用，一般是编辑器自动创建的。

<meta name="generator" content="vscode">
```

5. revised

```js
指定页面的最新版本

<meta name="revised" content="V2，2015/10/1">
```

6. robots

```js
告诉搜索引擎机器人抓取哪些页面，all / none / index / noindex / follow / nofollow

<meta name="robots" content="all">
```

### base标签

`base`标签定义了文档的基础`url`地址，在文档中所有的相对地址形式的`url`都是相对于这里定义的`url`而言的。为页面上的链接规定默认地址或目标。

## H5新特性

canvas、svg 、video、audio、语义标签、本地存储、地理定位、websocket

### **canvas、SVG**

- canvas是h5提供的绘图方法
- canvas绘图基于像素点，是位图，放大或缩小会失真，与分辨率有关；SVG是HTML标签描绘形状，放大或缩小不会失真，与分辨率无关
- canvas在js中绘制，SVG在HTML中绘制
- canvas不能为绘制对象绑定事件，svg可以为绘制对象绑定相关事件

用于绘画的元素，canvas绘制的图片会失真而SVG绘制的不会失真

**video、audio**

用于播放视频和音频的媒体

### **语义标签**

**优点：**

1. 页面内容结构化，通俗易懂
2. 利于SEO：爬虫依赖标签来确定**关键字的权重**，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的信息
3. 提升用户体验：例如title、alt可以用于解释名称或者解释图片信息，以及label标签的灵活运用。
4. 便于团队开发和维护
5. 方便其他设备解析：如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。

**常用元素：**header、nav、aside、footer、section、article

**本地存储**

sessionStorage、localStorage、indexDB加强**本地离线存储**

浏览器提供了storage事件来监听存储 

**离线web应用**

页面缓存指的还是有网络状态下，而**离线web应用指的是在没有网络状态可以运行应用**

```js
    if(window.applicationCache){
        //支持离线应用
    }
```

**manifest**文件是核心，记录着哪些资源文件需要离线应用缓存，要使用manifest，只需要在html标签中添加属性

```js
    <html manifest="cache.manifest">
```

**地理定位**

H5提供了Geolocation API访问地理位置，即通过window.navigator.geolocation来实现访问。页面第一次访问这个API需要获得用户许可，watchPositon可以对位置变化进行监听。

```js
getCurrentPosition()
watchPosition()
clearWatch
```

**webSocket**

基于应用层的协议，单个TCP连接上进行**全双工通讯**的协议

**CSS3**

**@media-query**（**媒体查询**）实现响应式布局

history路由，pushState()和replaceState()

## img标签和background-image区别

1. img 是 HTML 元素，基本用法如下：

```html
<img src="./img.jpg" alt="图片描述" />
```

background-image 则是一个 CSS 样式属性，用于设置元素的背景图片。

```css
.bg {
  background-image: url("./img.jpg");
}
```

2. 首先 img 是 DOM 树的一部分，属于网页的**内容**。

   有些客户端（比如爬虫、性能差的电子阅读器）不会解析样式或执行脚本，但包括 img 在内的 DOM 树是一定会解析的。即使客户端不解析图片，也可以获得 img 的 alt 内容，得到图片的描述。

   而 background-image 则是 **装饰**，用于美化内容。

   所以，如果你的图片是和正文内容有关的，建议使用 img，有利于语义化和 SEO。

3. img 即使不手动设置宽高，也会自定占据空间，将其他元素挤开。

   background-image 则作用在元素上，本身不能撑开元素。但是可以实现雪碧图的效果

4. **img 会比 background-image 先加载**，因为渲染过程为先解析 DOM 树，然后再应用样式树。如果 background-image 还是在一个外链的 css 文件中，加载时机会更晚。

   所以 background-image 更适合作为 banner 轮播图、广告图。因为 banner 通常都是广告，可以晚点加载，不要阻塞其他内容。

   

# CSS

## 颜色表示

1. RGB：十进制数值表示颜色，结构为rgb(R,G,B,A)，（其中 A 表示透明度），RGB 色彩模型的创建方式是将红色、绿色、蓝色映射到三维笛卡尔坐标系中。

   RGB三原色：RGB(255,0,0)这给定的三个参数表示红，绿，蓝的颜色值，由0到225的十进制表示RGB，RGB(100%,0%,0%)，使用百分号表示。

2. 十六进制值（HEX）：

   三位的十六进制；比如#F00(每个颜色由一个十六进制来表示)
   六位的十六进制；比如#FF0000(每个颜色由两个十六进制来表示)

   **RGB转HEX**

```js
// 摘自 https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L497
var mathRound = Math.round;
function pad2(c) {
  return c.length == 1 ? '0' + c : '' + c;
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [
    pad2(mathRound(r).toString(16)),
    pad2(mathRound(g).toString(16)),
    pad2(mathRound(b).toString(16))
  ];

  // Return a 3 character hex if possible
  if (allow3Char &&
    hex[0].charAt(0) == hex[0].charAt(1) &&
    hex[1].charAt(0) == hex[1].charAt(1) &&
    hex[2].charAt(0) == hex[2].charAt(1)
  ) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
```

3. HSL：

   HSL 的结构为 `hsl(H,S,L,A)`（其中 A 表示透明度），是一种将 RGB 色彩模型中的点在圆柱坐标系中的表示方式，这种色彩模型能够做到比基于笛卡尔坐标系的几何结构更加直观。

   [色相](https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E8%89%B2%E7%9B%B8)（Hue）：取值 0～360，指色彩的基本属性，0（或360）表示红色，120 表示绿色，240表示蓝色。

   [饱和度](https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E8%89%B2%E5%BA%A6_(%E8%89%B2%E5%BD%A9%E5%AD%A6))（Saturation）：取值 0～100%，指色彩的纯度，越高色彩越纯，低则逐渐变灰。

   [明度](https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E6%98%8E%E5%BA%A6)（Lightness）：取值 0～100%。

   **RGB转HSL算法：**

```js
// 摘自 https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L379
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = mathMax(r, g, b), min = mathMin(r, g, b);
  var h, s, l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  }
  else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }

    h /= 6;
  }
  return { h: h, s: s, l: l };
}
```



## 导入css文件

link、@import、style、行间样式、js

@import与link的区别：

- link是HTML的标签，除了导入css资源还可以导入别的资源，图片、字体等，在页面加载的时候同时会被加载，并且可以通过**js操作dom动态引入样式**，兼容性好
- @import是css语法，只能引入css资源；等页面加载完才可以加载样式；不支持IE5以下的版本

## 行级元素、块级元素

区别：

- 行级元素允许多个排列，块级元素独占一行
- 块级元素可以设置width、height，行级元素设置无效
- 行级元素水平设置margin、padding有效，竖直无效

行级元素：span、strong、em、a、bar

块级元素：div、p、ul、li、form、h

行块级元素：img、input

### 嵌套规则

1. 内联元素不能嵌套块级元素，块级可以嵌套内联元素
2. 有几个特殊的块级元素只能包含内联元素，不能包含块级元素，比如  h标签 和 p标签。
3. 特殊的<li>里面可以嵌套div。

### P标签内可以嵌套div吗

不能，内联元素可以嵌套内联元素,块级元素可以嵌套部分块级元素并也能嵌套内联元素,但内联元素不能嵌套块级元素。

## 获取元素的渲染高度

1. doucment.getElementById('IdName').style.height;
2. doucment.getElementById('IdName').clientHeight;
3. doucment.getElementById('IdName').offsetHeight;
4. doucment.getElementById('IdName').scrollHeight;

## bfc

块级格式化上下文，为页面中一个独立的小容器，是独立布局的，有自己的渲染规则，盒子里面的子元素的样式不会影响到外面的元素

**触发规则**：

- `BFC`就是一个块级元素，块级元素会在垂直方向一个接一个的排列

- `BFC`就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签

- 垂直方向的距离由margin决定， 属于同一个`BFC`的两个相邻的标签外边距会发生重叠

- 计算`BFC`的高度时，浮动元素也参与计算

触发方式：

- float属性不为none——left，right，inherit
- 根元素或包含根元素的元素
- overflow：hidden/auto 。不为visible
- position为**absolute或fixed**
- display：inline-block/table-cell/table-caption/table/inline-table/flow-root/flex/inline-flex/grid/inline-grid
- contain值为layout,content或strict。属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。

用途：

- 清除父元素内部子元素的浮动——子元素浮动脱离文档流，不能撑开父元素高度，此时设置父元素bfc，包裹子元素即可

- 解决外边距浮动问题。**margin collapsing——外边距叠加：**当相邻块元素的外边距结合为为单一的外边距时，就会取两者之间较大的值，出现于垂直方向。

  方法：

  - 父overflow: hidden
  - 父padding或border

- 两栏布局。前一个元素浮动，后一个元素触发bfc便可实现两栏布局

## 选择器

- 通配符选择器

- 标签选择器

- 类选择器

- ID选择器

- 属性选择器

- 后代选择器

  ```js
  ul li{
      border: 1px solid red;
  }
  ```

- 子选择器

  ```js
  选择父元素为 element 元素的所有 element 子元素。
  ul>li>p{
     border: 1px solid red;
  }
  ```

- 相邻兄弟选择器

  ```js
  下一个兄弟元素
  h1+p{
      color:red;
  }
  ```

- 一般兄弟选择器

  ```js
  是兄弟都可以
  h1~p{
     border: 1px solid red;
  }
  ```

- 伪类选择器

**伪类**：给已有的元素添加样式

link,:visited,:hover,:active,:first-child,:nth-child

**伪元素**：创建一些不存在DOM树的元素为其添加样式

::after, ::before

**优先级：**

| !important        | infinity |
| ----------------- | -------- |
| 行间样式          | 1000     |
| id                | 100      |
| class\|属性\|伪类 | 10       |
| 标签\|伪元素      | 1        |
| *                 | 0        |

## position有哪些属性

absolute:相对于父元素的第一个非static元素定位

relative:相对于出生位置进行定位

static:默认的，没有定位

fixed:相对于视口进行定位

sticky:relatived和fixed结合，粘性定位

该定位基于用户的滚动位置，

它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed; ，它会固定在目标位置。

## 居中方式

### 文本居中

单行文本：

-  水平居中：text-align:center;
- 垂直居中：line-hieght = hight

多行文本：

- 高度固定：display：table-cell； vertical-align:middle;
- 父级高度固定，嵌套行内元素：父级：display:table;子集：display：table-cell;vertical-align:middle;

### 图片居中

水平居中：

- 给img设display:inline-block;然后父级text-align：center；

- 给img设display:block; 同时设margin: 0 auto;

垂直居中：

- img父级display:table-cell; vertical:middle; height:xxx; 
- 定位 + transform: translate(-50%,-50%);
- 父级line-height == height +text-align:center;  <img>vertical-align:middle 

### 水平居中

1. text-align:center; (行级元素)

2. display:flex; justify-content:center;

3. 绝对定位+left+transform: position:absolute; left:50%; transform:translate(-50%,0);

4. 绝对定位 + left +marign-left: 

   ```js
   position:absolute;
   left:50%;
   marign-left:calc(-0.5*100px)
   ```

5. 绝对定位+left/right+margin

   ```js
   position:absolute;
   left:0;
   right:0;
   marign:0 auto;
   ```

### 垂直居中

1. flex

   ```js
   display: flex;
   align-items: center;
   ```

2. 父相子绝对定位+margin

   position:absolute; top:50%; marign-top:-50%;

   ```js
   .parent {
     width: 400px;
     height: 400px;
     border: 1px solid red;
     position: relative;
   }
   
   .child {
     width: 200px;
     height: 100px;
     background: blue;
     position: absolute;
     top: 50%;
     margin-top: -50px;
   }
   ```

3. 子相+transform

   position:absolute;+top:50%;+transform:translate(0,-50%)

4. table-cell+vertical-align

   父：display:table； 子：display:table-cell; + vertical-align:middle;

5. 借助伪元素

   ```js
   .parent {
     width: 400px;
     height: 400px;
     border: 1px solid red;
     text-align: center;
   }
   
   .child {
     width: 200px;
     height: 100px;
     background: blue;
     display: inline-block;
     vertical-align: middle;
   }
   .parent::before {
     height: 100%;
     content: '';
     display: inline-block;
     vertical-align: middle;
   }
   ```

   

### 水平垂直居中

**不定宽高**

1. 绝对定位+transform

    absolute; left:50%; top:50%; transform:translate(-50%,-50%);

2. table-cell

   父：display:table-cell; text-align:center; vertical-algin:middle;

3. flex

   父：flex；justify-content:center; align-items:center;

   父：flex； 子：margin：auto；

4. grid

   父：grid； 子：align-self:center; justify-self:center;

   父：grid;     子：margin:auto ;

**定宽高**

1. position：absolute; left:50%; top:50%; margin-left:-1/2 width; marign-top: -1/2 height;
2. position：absolute; left:calc(50%-1/2width)；top：calc(50%-1/2height)
3. position: absolute; left:0; top:0;right:0; bottom:0; margin:auto;
4. positon: absolute; left:50%; top:50%; transform:translate(-50%,-50%);
5. 父：display:flex; justify-content:center; align-items:center;
6. 父：display:grid; 子：justify-self:center; align-self:center;

## bfc+清除浮动

bfc：块级格式化上下文，盒子里面的元素不会影响外面的元素。

**触发条件**：

1. dispaly：inline-block; table-cell; table-caption
2. position:不为static和relative； absolute/fixed
3. overflow:不为vasible;  hidden/auto
4. float:不为none；为left，right，inherit

**BFC的规则**：

- `BFC`就是一个块级元素，块级元素会在垂直方向一个接一个的排列
- `BFC`就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签
- 垂直方向的距离由margin决定， 属于同一个`BFC`的两个相邻的标签外边距会发生重叠
- 计算`BFC`的高度时，浮动元素也参与计算

**解决问题**：

1. 使用Float脱离文档流，高度塌陷。清除父元素内部子元素的浮动——子元素浮动脱离文档流，不能撑开父元素高度，此时设置父元素bfc，包裹子元素即可

2. margin边距重叠

   **解决办法:**

   - 外层元素 overflow:hidden;
   - 外层元素添加padding
   - 内层元素绝对定位 postion:absolute:
   - 内层元素 加float:left;或display:inline-block;
   - 外层元素透明边框 border:1px solid transparent;

3. 解决外边距浮动问题。**margin collapsing——外边距叠加：**当相邻块元素的外边距结合为为单一的外边距时，就会取两者之间较大的值，出现于垂直方向。

## 清除浮动

当一个元素是浮动的，如果没有关闭浮动时，其父元素不会包含这个浮动元素，因为此时浮动元素从文档流脱离

## 两栏布局

1. 双inline-block; 一个定宽，另一个通过calc计算属性；
2. 双float+calc；左边定宽，右边calc计算；
3. 左:float:left; 右：margin-left:-左width; 父元素清除浮动
4. 左侧左浮，右侧右浮动，右侧计算宽度
5. 父：position：relative; 左：position:absolute+定宽    右：margin-left:左width；
6. 父：display：flex；子：左边定宽；右边flex：1【 grow（扩展），shrink（缩小），basis的缩写（flex ：1 ；1 1 0%）】；
7. 父：display:flex; 子：左边：flex：0 0 auto;右边：flex：11 auto；

## 三栏布局

1. flex

   ```js
    		.box{
               width: 100vw;
               height: 100vh;
               display: flex;
           }
           .left,.right{
               width: 100px;
           }
           .left{
               background-color: red;
           }
           .right{
               background-color: yellow;
           }
           .middle{
               flex:1;
               background-color: blue;
           } 
   
   
   <div class="box">
           <div class="left">左</div>
           <div class="middle">中</div>
           <div class="right">右</div>
     </div>
   ```

   2. 左，右，中     float：left； float：right;  margin-left+margin-right
   3. 定位： 父相子绝   left：0；  right：0；  中间：left：100px；right：100px;

## flex

主轴，交叉轴

### 容器属性

- flex-direction：主轴方向
- flex-wrap：换行方式
- flex-flow：direction和wrap的简写
- justify-content：水平对齐方式
- align-items：交叉轴对齐方式
- align-content：多根轴线对齐方式

### 项目属性

- order：项目排列顺序
- flex-grow：项目放大比例，默认为0
- flex-shrink：项目缩小比例，默认为1
- flex-basis：分配多余空间前，项目占据主轴空间。默认为auto
- flex： grow（扩展），shrink（缩小），basis的缩写（flex ：1 ；1 1 0%）
- align-self：单个项目的对齐方式

## 单位长度

px：相对长度单位，像素px是相对于显示器屏幕分辨率而言的

rem ：相对于HTML根元素

em：相对于父元素      默认情况下`font-size = 16px`,那么`1em = 16px`

vh , vw：相对于屏幕视口，vh 和 vw 就是根据窗口的宽高，分成100等份

## css3新特性

transform:变形     

​		rotate(旋转)、scale(缩放)、translate(移动)

​		translate3D() 

​		 因为`transform`只会影响当前元素的状态，达到类似`position: relative;`的效果，而且`transform`是默认基于元素的中心进行转换的

transition:过渡      transition: [属性名] [持续时间] [速度曲线] [延迟时间];   transition: 0.5s ease;

animation:动画      [函数名]   [时间]   [动画的速度曲线]  

```html
.opacity {
animation: 0.3s 函数名 linear;
}
@keyframes [函数名]{

	0% {transform:translate(0px,0px)}

	50% {}

	100% {}

}
```

![image-20220302174311783](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220302174311783.png)		

## 硬件加速

[CSS3](https://so.csdn.net/so/search?q=CSS3&spm=1001.2101.3001.7020) 硬件加速又叫做 **GPU 加速**，是利用 GPU 进行渲染，
减少 CPU 操作的一种优化方案。由于 [GPU](https://so.csdn.net/so/search?q=GPU&spm=1001.2101.3001.7020) 中的 transform 等 CSS
属性不会触发 repaint，所以能大大提高网页的性能。

原理：浏览器首先将页面解析成DOM树，DOM树和CSS让浏览器构建渲染树，渲染树包括渲染对象。每个渲染对象会被分配到一个图层中，**每个图层会被更新到GPU中**，由于GPU中的transform等CSS属性不触发repaint，因此不需要重绘，单独处理，所以能大大提高网页的性能。

开启硬件加速方式：

1、transform

2、opacity

3、filter

强行开始加速：

transform：translate3d(0,0,0);

注意问题：

1、过多的使用GPU处理会导致内存问题，可能导致浏览器崩溃。

2、在GPU渲染字体会导致抗锯齿无效，因为GPU和CPU的算法不同，因此即使最终硬件加速停止了，文本还是会在动画期间显示的很模糊，尽量不要包含文字。

## CSS优雅降级和渐进增强

**在高级浏览器中使用CSS3，而在低级浏览器只保证最基本的功能**。

**渐进增强**

一开始就**针对低版本浏览器**进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

**优雅降级**

一开始就构建**站点的完整功能**，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

## box-shadow

属性值：

h-shadow 必需的。水平阴影的位置。允许负值
v-shadow 必需的。垂直阴影的位置。允许负值
blur 可选。模糊距离
spread 可选。阴影的大小
color 可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表
inset 可选。从外层的阴影（开始时）改变阴影内侧阴影

```js
box-shadow:    0px -10px 0px 0px #ff0000,   /*上边阴影  红色*/
                -10px 0px 0px 0px #3bee17,   /*左边阴影  绿色*/
                10px 0px 0px 0px #2279ee,    /*右边阴影  蓝色*/
                0px 10px 0px 0px #eede15;    /*下边阴影  黄色*/
```



## 响应式布局

响应式布局：一套代码可以兼容不同的设备，在不同设备上体现效果。一个网站能够兼容多个终端，而不是为了每一个终端做一个特定的版本。

自适应布局：根据不同的设备，写不同的代码。开发多套界面来适应不同的终端。

### 媒体查询

@media针对不同的媒体类型定义不同的样式，针对不同屏幕的大小，编写多套样式，达到自适应的效果。

当屏幕宽度增大或者减小的时候，后面的样式会覆盖前面的样式。所以移动端使用的是min-width，PC端使用的max-width

```js
/* 媒体查询语法 */
@media 媒体类型 {
    /* css样式 */
}
@media 媒体特性 {
    /* css样式 */
}
@media 媒体类型 and 媒体特性 {
    /* css样式 */
}
@import url('xxx.css') 媒体特性;


@media screen and (max-width:960px){
	body{
        //样式
    }
}
```

### 百分比

浏览器中组件的宽和高随着浏览器的高度变化而变化，从而实现响应式的效果。

**特点：**

子元素的height和width使用百分比，相对于子元素的直接父元素；

子元素的top和bottom设置百分比，相对于直接非static定位的父元素高度；left和right同理

子元素的padding设置百分比，不论垂直还是水平，相对于直接父元素的width，与height无关

子元素的margin设置百分比，不论垂直还是水平，相对于直接父元素的width

子元素的border-radius、translate、background-size等相对于自身

计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。

**缺点：**

- 计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。

- 可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如`width`和`height`相对于父元素的`width`和`height`，而`margin`、`padding`不管垂直还是水平方向都相对比父元素的宽度、`border-radius`则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。

### rem布局

rem单位是相对于根元素HTML的font-size来决定大小的。当页面的size发生变化时，只需要改变`font-size`的值，那么以`rem`为固定单位的元素的大小也会发生响应的变化。如果通过`rem`来实现响应式的布局，只需要根据视图容器的大小，动态的改变`font-size`即可。

**思想：**

- 一般不给元素设置具体宽度，对于小图标可以设置具体宽度值，高度值可以设置固定值
- 所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值）
- js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定

缺点：必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，必须将font-size的代码放在css样式之前

### 视口单位

`css3`中引入了一个新的单位`vw/vh`，与视图窗口有关，`vw`表示相对于**视图窗口**的宽度，`vh`表示相对于视图窗口高度，除了`vw`和`vh`外，还有`vmin`和`vmax`两个相关的单位。

### 图片响应式

这里的图片响应式包括两个方面，一个就是**大小自适应**，这样能够保证图片在不同的屏幕分辨率下出现压缩、拉伸的情况；一个就是根据不同的屏幕分辨率和设备像素比来尽可能**选择高分辨率的图片**，也就是当在小屏幕上不需要高清图或大图，这样我们用小图代替，就可以**减少网络带宽**了。

**实现方式：**

1. 使用max-width（图片自适应）
2. 使用srcset
3. 使用background-image
4. 使用picture标签

## 前端SEO优化

搜索引擎优化，采用易于搜索引擎索引的合理手段，使网站各项基本要素适合搜索引擎检索原则，对用户更友好，更适合爬虫获取信息使得用户在访问网站时能排在前面。

- 控制首页链接数量
- 扁平化的目录层次，即目录尽量不超过三级
- 导航优化，图片代码必须添加alt和title
- 网站的结构布局
- 利用布局，将重要内容的html代码放在前面
- 控制页面大小，减少http请求，提高网站的加载速度

## 怎样写出更好的CSS有哪些方法或者说遵循哪些基本原则

# js

## 0.1 + 0.2 !== 0.3 解决办法

因为在计算机中，无论是定点数还是浮点数都是以**多位二进制**的方式进行**存储和运算**的。

在JS中数字采用的IEEE 754的双精度标准进行存储，在小数点后面还有很多位，所以不相等。

ES6 中，已经为我们提供了这样一个属性：Number.EPSILON，而这个值正等于2^-52。这个值非常非常小，在底层计算机已经帮我们运算好，并且无限接近0，但不等于0,。这个时候我们只要判断(0.1+0.2)-0.3小于Number.EPSILON，在这个误差的范围内就可以判定0.1+0.2===0.3为true

```js
function numbersEqual(a,b){
    return Math.abs(a-b)<Number.EPSILON;
}
var a=0.1+0.2， b=0.3;
console.log(numbersEqual(a,b));    //true
```

## typeof String(1) 和 typeof new String(1)

typeof String(1)：“string”

typeof new String(1) ：“object”

## typeof null == 'object'

javascript中不同对象在底层都表示为二进制，而javascript 中会把二进制前三位都为0的判断为object类型，而null的二进制表示全都是0，自然前三位也是0，所以执行typeof时会返回 ‘object’。

## 严格模式

use strict

1. 全局变量声明时，必须加关键字(var)。严格模式下重复申明会报错：a is not defined

2. this无法指向全局对象。严格模式下，this为undefined；正常模式下，this指向window。

3. 函数不允许出现重名参数。

4. 删除变量，必须设定configurable = true。

5. arguments对象不允许被动态修改。

   ```js
    正常模式：function fn(a){
                       a=20;
                       console.log(a);                //20
                       console.log(arguments[0]);     //20
                   }
                   fn(10);
   
           严格模式：function fn(a){
                       a=20;
                       console.log(a);                //20
                       console.log(arguments[0]);     //10
                   }
                   fn(10);
   ```

   

## 双等和三等

== 有类型转换，=== 无类型转换，严格模式

### 双等的转化规则

1. 如果有一个操作数是boolean，则在比较之前先转换为数值

2. 如果一个是字符串，一个是数值，在比较之前先将字符串转换为数值

3. 如果一个是对象，另一个不是，调用对象的valueOf方法，得到基本类型值按照前面规则比较

   ![image-20210604190943470](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210604190943470.png)

4. null ==  undefined //true

5. NaN == NaN //false

   只要有一个为NaN，则返回false

6. 如果两个操作数都是对象，则比较他们是否为同一个对象。如果两个操作数都指向同一个对象，则返回true

### 对象怎么转换为原始类型

1. 优先调用内置函数Symbol.toPrimitive()
2. 调用valueOf函数
3. 调用toString函数
4. 没有返回原始类型，会报错

## a == 1 && a == 2 && a == 3

**==比较类型转换**
如果两边的数据类型不一致，先转换为同样的数据类型进行比较

特殊比较

```js
/* 两个对象进行比较，比较的是堆内存的地址，数组也一样 */
console.log({} == {}) // false
/* 对象和字符比较，是把对象进行 toString() 转换为字符串再比较 */
console.log([12] == '12') // true
/* null 和 undefined 比较 */
console.log(null == undefined) // true
/* NaN 和谁都不相等 */
console.log(NaN == NaN) // false
```

实现：可以用valueof方法

```js
// 重写valueOf()方法
        //利用隐式转换时，会调用valueOf()方法，来实现对其值的++操作
        // valueOf的意思是返回最适合该对象类型的原始值，而toString则是将在该对象类型的原始值以字符串形式返回。
        let obj = {
            i: 1,
            valueOf: () => {
                return obj.i++
            }
        }
        console.log(obj == 1 && obj == 2 && obj == 3);//true

//toString方法
var a = {
	n: 0,
	toString: function() {
		return ++this.n
	}
}
/* 对象 a 调用的是自己内部的 toString 方法，不是其原型链上的 */
if (a == 1 && a == 2 && a == 3) {
	console.log('ok') // ok
}

```



## null和undefined

**undefined：未定义。**

使用场景：

- 声明了变量但是未赋值
- 访问对象上不存在的属性或者未定义的变量
- 函数定义了形参但是没有实参

**null：空值**。表示一个对象被人为的重置为空对象。

使用场景：

- 定义的变量将用于保存对象，将变量初始化为null

- 闭包中内存泄漏，使用null清除。

## 判断NAN

- isNaN

- ```
  Object.is(a,NaN)
  ```

## 参数传递

对于基本类型：

```js
let num = 5 
function add(num) {
    num += 10
}
add(num)
console.log(num)    //5
```

基本类型的参数是**按值传递**的。大家可以将函数的传参当作函数内部的局部变量，当函数执行完成后，该变量会被自动销毁的。

对于引用类型：

```js
let person ={ name: "Jerry" }    
function setName(obj) {        
    obj.name = "Tom"    
}    
setName(person)    
console.log(person.name)    //Tom
```

将参数复制了一个副本到局部变量，只不过这个副本是指向堆内存的地址罢了。

```js
let person ={ name: "Jerry" }    
function setName(obj) {        
    obj.name = "Tom"        
    obj = new Object()    // 注意这里        
    obj.name = "Spike"    
}    
setName(person)    
console.log(person.name)    //Tom

```

函数参数传递的并**不是变量的引用**，而是**变量拷贝的副本**，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。





## 判断类型方法

1. typeof  对于复杂数据类型判断不准确，为object，并且typeof null == ‘object’

2. constructor：

   `constructor` 可以被重写，所以不能确保一定是数组

   ```js
   const str = 'abc';
   str.constructor = Array;
   str.constructor === Array 
   // true
   ```

3. instanceof   在原型链上判断，左边的原型链上是否有右边的原型

4. Object.prototype.toString.call()，使用toString的原因是toString的方法可以被改写

   Array.isArray有兼容性的问题，不能兼容IE8

## Symbol

Symbol是一个函数，但是不是构造函数，所以不能new；

symbol类型的变量通过`Symbol`产生，特点是独一无二，所以不相等;

symbol可以作为对象的`key`来使用，可以保证不会与其他属性名产生冲突；

```js
let sym = Symbol();
typeof sym;//symbol
```



## 数组方法

**改变数组：**

> push、pop、shift（从前面删除一个元素）、unshift（从前面添加一个元素）、reverse、sort、splice（截取数组的一段）split（字符串转数组）

**不改变数组**：（返回新数组）

> slice、join、concat、include、filter、reduce、map

**splice**：插入：arr.splice(在下标key之前插入, 删除几个元素，插入的元素)

			删除：let arr = ["I", "study", "JavaScript"];
				 let b = arr.splice(1, 1); // 从索引 1 开始删除 1 个元素
				 alert( arr ); // ["I", "JavaScript"]
				alert( b ); //["study"]

slice：可以接收一或两个参数，即要返回项的起始和结束位置。

```js
var colors = ['red', 'green', 'blue', "red", "green", "blue"]
var colors2 = colors.slice(1, 4)
console.log(colors) // "red", "green", "blue", "red", "green", "blue"]
console.log(colors2) // ["green", "blue", "red"]
```



concat、slice、splice返回新数组

**filter**：过滤，返回一个新数组，不改变原数组

**map**：映射，map不改变原数组但是会返回**新数组**，可以使用break中断循环，return的值就是新数组的值

**forEach**：改变原数组，效果和for循环相同，在原数组上遍历改变，没有返回值；forEach需要使用return跳过循环中的迭代

**reduce**：返回新数组

​				用法：计算数组中元素出现的次数、数组去重（reduce+concat）、数组扁平化

```js
参数
array.reduce(function(total, currentValue, currentIndex, arr){
    total // 上一次循环体内返回的值
          // 如果指定 initialValue，则第一次循环的total为initialValue，    
          // 否则为array的第一个元素
    currentValue // 当前的元素
          // 如果指定 initialValue，则第一次循环的 currentValue 为 array的第一个元素，    
          // 否则为array的第二个元素
    currentIndex   //currentValue 的索引
    arr   // 当前遍历的数组
    
}, initialValue)
```

用reduce模拟map

```js
Array.prototype._map = function(fn, callbackThis) {
    // 最终返回的新数组
    let res = [];
    // 定义回调函数的执行环境
    // call第一个参数传入null，则 this指向全局对象，同 map的规则
    let CBThis = callbackThis || null;
    this.reduce((brfore, after, idx, arr) => {
        // 传入map回调函数拥有的参数
        // 把每一项的执行结果push进res中
        res.push(fn.call(CBThis, after, idx, arr));
    }, null);
    return res;
};

```

### 方法对空位的处理

![image-20211207221241344](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211207221241344.png)

## 类数组转数组

类数组概念：类数组是具有length属性，但是不具备数组原型上的方法，常见的有arguments和dom操作返回的结果

- Array.from(类数组)
- Array.prototype.slice.call(类数组) //  由于类数组不具有数组原型上的方法，所以这样写，这样写可以将具有length的对象转为数组
- 扩展运算符：内部是for...of循环
- 使用concat。Array.prototype.cancat.apply([],类数组)

## 原型原型链

![WechatIMG114.jpeg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9afcd1172d340508d25c095b1103fac~tplv-k3u1fbpfcp-watermark.awebp?)

## 继承

### 原型链继承

让父类的实例等于子类的原型

```js
function Father (){}
function Child (){}
Child.prototype = new Father()
```

- 优点：简单
- 缺点：子类实例可以修改父类引用类型的值；无法传参

**例子:**

```js
		function Person() {
            this.name = 'apple'
        }
        Person.prototype.friend = "xiaoqi";
        function From() {
            this.from = "China"
        }
        From.prototype = new Person()
        const persion_1 = new Person()
        persion_1.friend = 'yaya'
        const persion_2 = new From()
        persion_2.friend = 'haha'
        const p3 = new Person()
        console.log(p3.friend)//xiaoqi
        console.log(persion_2.friend)//haha
        console.log(persion_1.friend)//yaya
```



### 借用构造函数继承

通过call改变子类的this指向，继承父类的实例，但是**不会继承父类的原型对象**

```js
function Father(){}
function Child(){
    Father.call(this,params)//让father的this指向child
}
```

- 优点：子类实例不会修改父类，影响其他子类；可以传参
- 缺点：每个子类都有父类实例的副本，影响性能；子类不能继承父类原型上的属性

**例子**

```js
		function Person() {
            this.name = 'apple'
        }
        Person.prototype.friend = "xiaoqi";
        function From() {
            Person.call(this)
        }
        // From.prototype = new Person()
        const persion_1 = new Person()
        persion_1.friend = 'yaya'
        const persion_2 = new From()
        const p3 = new Person()
        console.log(persion_1.friend)//yaya
        console.log(persion_2.friend)//undefined
        console.log(p3.friend)//xiaoqi
```

### 组合式继承

结合原型链继承和借用构造函数继承的方法

```js
function Father(){}
function Child(){
    //第二次调用
    Father.call(this,params)
}
//第一次调用
Child.prototype = new Father()
Child.prototype.constructor = Child
```

- 优点：避免共享；可以向父类传参
- 缺点：会调用两次父类构造函数，在Child.prototype中有父类属性，在Child实例中也有

### 原型式继承

创建一个空函数，将已有对象赋给新对象的原型，返回一个实例对象(浅拷贝)

```js
function object(obj){
    function F(){}
    F.prototype = obj
    return new F()//返回一个实例对象
}
```

- 缺点：父类中的引用类型值会被子类实例对象修改，共用；无法传参

传的是地址，子类会修改父类引用类型的值0

**例子**

```js
function object (obj) {
    function F () {};
    F.prototype = obj;
    return new F();
}
const cat = {
  heart: '❤️',
  colors: ['white', 'black']
}

const guaiguai = object(cat)
const huaihuai = object(cat)

console.log(guaiguai)
console.log(huaihuai)

console.log(guaiguai.heart)
console.log(huaihuai.colors)

/*
F {}
  __proto__: colors: (2) ["white", "black","test"]heart: "❤️"
    __proto__: Object
F {}
  __proto__: colors: (2) ["white", "black","test"]heart: "❤️"
    __proto__: Object
❤️
["white", "black","test"]
*/

```

### 寄生式继承

在原型式继承的基础上，增强对象，返回构造函数

```js
function fun(){
	let clone = object(person)
    clone.say = function(){}
    return clone
}
```

缺点：同原型式继承

### 寄生式组合继承

是**借用构造函数**继承和**寄生式继承**的组合

```js
function inheritPrototype(child,father){
    //创建对象
	let prototype = object(father.prototype)
    //增强对象，为创建的副本添加constructor属性
    prototype.constructor = child
    //指定对象
    child.prototype = prototype    
}
```

- 优点：高效率，只调用一次父构造函数；原型链不变

### es6  class中extends方法

```js        
class Father{
    constructor(){
		this.title = 'hi'
    }
    fn(){
        this.name = 'lin'
        return this.name
    }
}
class Child extends Father{
	constructor(){
		super()
        this.name = 'hahhah'
    }
    
}
let child = new Child()
console.log(child.fn())//lin
```

## 闭包

闭包就是有权访问另一个函数作用域中变量的函数，也就是存在对上级作用域的引用。

函数可以作为一个函数的参数，也可以是函数的返回值

我们可以将执行环境想象为一个栈，栈底为全局执行环境，每检测到一个函数便将其执行环境入栈，由此栈顶的执行环境可以通过向栈底查找的方式寻找到本执行域中不存在的值。每执行一个函数便将其从栈中弹出，导致后续的函数无法访问被弹出函数的变量。闭包就是将需要保存执行域的函数通过return的方式返回到外部并保存其函数执行域，使外部可以访问函数内部的值。

闭包的**作用**：

- 保护函数的私有变量不受外部的干扰
- 将上级作用域的引用保存下来，实现**方法或者属性的私有化**

**使用场景：**

- 使用return返回函数
- 函数作为参数
- 定时器setTimeout和自执行函数
- 防抖节流
- 函数柯里化

**问题**：

会存在内存泄漏的问题，也就是除非手动将变量置为null，否则它一直在环境中。

**如何定位内存泄漏：**

1. 使用 Chrome DevTools ：Performance  定位内存泄漏

   打开准备分析的页面和 DevTools 的 Performance 面板，勾选 Memory 并开始录制，在模拟用户操作一段时间后结束录制，DevTools 会将这段时间内的页面行为活动进行记录和分析。

   通过生成的结果可以直观查看到内存时间线，了解内存随时间的占用变化，如果内存占用曲线成阶梯状一直上升，则可能存在内存泄漏。按需选取时间线中的区域片段，检查对应时间段内的活动类型和时间占用，作为排查和定位内存泄漏的辅助办法。

2. Node.js 中的内存泄漏定位

   如果需要定位 Node.js 中的内存泄漏，启动 Node.js 时带上 --inspect 参数，以便利用 Chrome DevTools 工具生成 Memory 快照数据。启动 Node.js 服务后，打开 Chrome DevTools，会有 Node 标识，点击可以打开 Node 专用 DevTools。

## 作用域

函数作用域是在函数定义时生成的。

![image-20220102223003584](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220102223003584.png)

打印100，放在全局，但是不推荐

![image-20220102223219745](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220102223219745.png)

a未定义，b=10

## this指向

this指向最后一个调用它的函数。

默认情况下，this指向window；显示调用情况下，通过call,apply,bind改变this指向；通过new一个构造函数，this指向构造函数的实例；箭头函数的this继承自外层函数的this。（在全局执行上下文中，this指向全局对象；在函数执行上下文中，this的值取决于该函数是如何调用的，如果被一个引用对象调用，那么this会被设置为那个对象，否则this的值被设置为全局对象或者undefined）。

改变this指向：

- 可以通过call，bind，apply方式改变。
  - call()，第一个参数为函数内this的值，参数需要一个一个列出来
  - apply(),第一个参数为函数内this的值,第二个参数可以是Array的实例，也可以是arguents对象
  - bind()，会创建一个新的函数实例，其this值会被绑定到传给bind对象。例如，f.bind(obj)，实际上可以理解为obj.f()，这时，f函数体内的this自然指向的是obj，bind是创建一个新的函数，必须手动去调用
- 使用箭头函数
- 在函数内部使用_this = this，即使用变量保存下来
- new实例化一个对象

call、apply应用场景：

1、类数组转数组：Arrary.prototype.slice.call()

2、判断数据类型：Object.prototype.toString.call()

3、数组追加：

```js
var arr1 = [1,2,3];
var arr2 = [4,5,6];
[].push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
console.log(arr2); // [4, 5, 6]
/* ES6的方法 */
arr1.push(...arr2); // [1, 2, 3, 4, 5, 6]
```

4、数组合并

```js
var arr1 = [1, 2, { id: 1, id: 2 }, [1, 2]];
var arr2 = ['ds', 1, 9, { name: 'jack' }];
// var arr = arr1.concat(arr2);//简单做法
Array.prototype.push.apply(arr1,arr2)
console.log(arr1);
/* ES6的方法 */
[...arr1,...arr2]
```

手写call、apply、bind：

call、apply：注意this指向和参数，获取新的上下文context，添加属性fn（symbol），获取this（调用this的函数），执行函数context.fn(...args)

bind：返回一个函数，函数结果也用return返回，注意返回函数的new调用

## 垃圾回收机制

​	GC即Garbage Collection，程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而GC就是负责回收垃圾的。

### 垃圾回收策略

#### 标记清除策略

​	**标记清除（Mark-Sweep）**，目前在JavaScript引擎里这种算法是最常用的，到目前为止的大多数浏览器的JavaScript引擎都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工。

​	此算法分为**标记**和**清除**两个阶段，标记阶段为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。

整个标记清除算法大致过程就像下面这样

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全部标记为0.
- 然后从各个根对象开始遍历，把不是垃圾的节点改为1.
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

**优点：**标记清除算法的优点只有一个，那就是实现比较简单，打标记无非打与不打两种情况，这使得一位二进制（0和1）就可以为其标记，非常简单。

**缺点：**标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，使得下次为对象分配内存空间的时候找不到合适的内存块耗费时间

而**标记整理算法**就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。

#### 引用计数策略

**引用计数（Reference Counting）**，这其实是早先的一种垃圾回收算法，它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

它的策略是跟踪记录每个变量值被使用的次数

- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
- 如果同一个值又被赋给另一个变量，那么引用数加 1
- 如果该变量的值被其他的值覆盖了，则引用次数减 1
- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

**优点：**可以立即回收垃圾，而且相对于标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。

**缺点：**首先它需要一个计数器，此计数器需要占很大的位置，最严重的问题是无法解决循环引用无法回收的问题。

#### V8对GC的优化

##### 新老生代

​	V8的垃圾回收策略主要基于分代式垃圾回收机制，V8中将堆内存分为新生代和老生代两区域，用不同的垃圾回收器也就是不同的策略管理垃圾回收。

​	新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持1~8M的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。

##### 新生代垃圾回收

​	新生代对象是通过一个名为 **Scavenge** 的算法进行垃圾回收，在 **Scavenge算法** 的具体实现中，主要采用了一种复制式的方法即 **Cheney算法** ，Cheney算法中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为**使用区**，一个是处于闲置状态的空间我们称之为 **空闲区**，如下图所示

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-1.image)

​	新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作。

​	当开始进行垃圾回收时，新生代垃圾回收器会对使用区的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。

​	当一个对象经过多次复制后依然存活，它将被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。

​	另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。

##### 老生代垃圾回收

​	相较于新生代，老生代的垃圾回收机制就比较简单，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区，然后复制来复制去就会非常耗时，从而导致回收效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就是上文所说的标记清除算法了。

#### 再说V8中的GC优化

​	V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，但是老生代垃圾回收到底采用哪个策略呐？

其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的

​	老生代主要使用并发标记，主线程在开始执行 `JavaScript` 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）

​	标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）

同时，清理的任务会采用增量的方式分批在各个 `JavaScript` 任务之间执行

## js编译过程

![image-20220216190921046](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220216190921046.png)

## js执行机制

https://juejin.cn/post/6844903788629721096

js引擎执行过程分为三个阶段：

- 语法分析
- 预编译阶段
- 执行阶段

1）**语法分析**：分析该js脚本代码块的语法是否正确，如果出现不正确，则向外抛出一个**语法错误（SyntaxError）**，停止该js代码块的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入预编译

2） **预编译阶段**：创建go对象，找形参和变量声明，赋值为undefined；将实参和形参相统一；找函数声明并赋值函数体

1. 运行环境：

   - 全局环境：js代码加载完毕后，进入代码预编译即进入全局环境
   - 函数环境：函数调用时，进入该函数环境，不同的函数则函数环境不同
   - eval：不建议使用，由安全，性能等问题
2. 函数调用栈：使用栈存取的方式进行管理运行环境



3）**创建执行上下文**：

1. **创建变量对象**：创建变量对象发生在预编译阶段，但尚未进入执行阶段，该变量对象都是不能访问的，因为此时的变量对象中的变量属性尚未赋值，值仍为undefined，只有进入执行阶段，变量对象中的变量属性进行赋值后，变量对象（Variable Object）转为活动对象（Active Object）后，才能进行访问，这个过程就是VO –> AO过程。vo：变量对象，存储了在上下文中定义的变量和函数声明，无法访问，必须是js中以var声明的变量才会记录在这里，let或者const声明的变量不会存在，必须是显式声明的函数，函数表达式不会被记录
   - 创建arguments对象，检查当前上下文的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程
   - 检查当前上下文的函数声明
   - 检查当前上下文的变量声明
2. **建立作用域链**：作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。作用域链的第一项永远是当前作用域(当前上下文的变量对象或活动对象)，最后一项永远是全局作用域（全局执行上下文的活动对象）
3. **确定this指向**

4）**执行阶段**：

事件循环：

![image-20211215202507534](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211215202507534.png)

首先，整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务，异步任务两部分，同步任务会直接进入主线程依次执行，异步任务会再分为宏任务和微任务，宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中。微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中。当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务，该过程不断重复。event table：异步流程

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。

`await` 以前的代码，相当于与 `new Promise` 的同步代码，`await` 以后的代码相当于 `Promise.then`的异步

常见微任务：process.nextTick ()-Node；Promise.then()；catch；finally；Object.observe；MutationObserver

常见宏任务：主代码块；setTimeout；setInterval；setImmediate ()-Node；requestAnimationFrame ()-浏览器

## DOM事件流 

dom事件流三个阶段：

- 事件捕获
- 到达目标
- 事件冒泡

现在chrome使用的是事件冒泡处理事件流，如果使用事件捕获需将addeventlistenerhttps://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener最后的参数设置为true，默认为false事件冒泡

**事件委托**：一般来讲，会把一个或者一组元素的事件委托到它的浮层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。在父元素上绑定事件，然后在执行事件的时候再去匹配判断目标元素，之后通过事件冒泡触发父元素上的绑定事件，执行函数。

**事件捕获**：事件会从最外层开始发生，直到最具体的元素。

**事件冒泡**：事件的触发响应会从最底层目标一层层地向外到最外层（根节点）

​				阻止事件冒泡：event.stopPropagation()，event.cancelBubble;  

**e.target 和 this 的区别**

this 返回的是绑定事件的对象（元素）

e.target 返回的是点击的那个对象，就是谁触发了这个事件,如点击事件->谁被点了

target：触发事件的源组件(事件注册/绑定所在组件)

currentTarget：事件触发的当前事件

（当前事件，可能是触发事件的源组件，可能是触发的事件组件（即触发事件源组件的子元素），此时点击子元还是父元素，都是当前事件，应用e.currentTarget）。

```js
var ul = document.querySelector('ul');
ul.addEventListener('click', function (e) {
    console.log(this);
    console.log(e.target);
})

// <ul>...</ul>
// <li>123</li>
```

## 深浅拷贝

**赋值：**

当我们把一个对象赋值给一个新的对象时，赋的是该对象在栈中的地址，而不是堆中的数据 也就是赋值之后，两个对象指向同一个存储空间。无论哪个对象发生改变，其实都是改变的堆中的数据

**浅拷贝：**

在栈中开辟一个新空间，对于基本数据类型，拷贝的是它的值，对于引用数据类型，拷贝的是它内存中的地址，所以修改会改变原对象。

方法：

Object.assign()、Array.prototype.slice() 、 Array.prototype.concat()、扩展运算符、函数库lodash的_.clone方法

**深拷贝：**

也是在栈中开辟新空间，基本数据类型，拷贝的值，引用数据类型，在堆中重新分配内存，不同的地址，相同的值，互不影响。

方法：

1. JSON.parse(Json.stringfy())

   缺点：由于用到了JSON，JSON中自身有缺陷，不支持函数、undefined、RegExp、Date、循环引用对象

   - 对于函数，变为null
   - undefined，忽略掉
   - RegExp，被克隆后为空对象
   - Date，转为字符串
   - 循环引用对象，报错

2. 递归变量克隆

## 箭头函数  

- this指向，需要通过查找作用域链来确定this的值，继承自外层第一个普通函数的this，被继承的普通函数的this指向改变，箭头函数的this指向也会跟着改变

- 箭头函数外层没有普通函数，严格模式和非严格模式下它的this都指向window（全局对象）；

  普通函数的默认绑定规则是：在非严格模式下，默认绑定的this指向全局对象，严格模式下this指向undefined

- 没有自己的arguments对象

- 不能用new方法调用，不支持new.target(`new.target`会返回该函数的引用)

- 没有自己的prototype，因为不能使用new调用箭头函数，所以也没有构建原型的需求，也没有this

- 没有super

## ajax

```js
var xhr = new XMLHttpRequest();//创建对象
xhr.open('method','url'，'async');//配置请求，初始化设置请求方法和url
xhr.send();//构建请求体，发送到服务器
xhr.setRequestHeader('Content-Type','application/json');//设置请求头
//事件绑定，处理服务端返回的结果
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){[
        if(xhr.status >= 200 && xhr.status < 300){
   			// some code         
        }
    ]}
}
```

### promise封装ajax

```js
const getJson = function(url){
    return new Promise(function(resolve,reject){
        const handler = fucntion(){
            if(this.readyState !== 4){
                return;
            }
            if(this.status == 200){
                resolve(this.response);
            }else{
                reject(new Error(this.statusText));
            }
        };
        const client = new XHRHttpRequest();
        client.open('GET',url);
        client.onreadystatechange = handler;
        client.responseType = 'json';
        client.setRequestHeader('Accept','application/json');
        client.send();
    });
    return promise;
}
getJson("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
```

### readystate 五个状态

0 初始化xhr

1 open了但还没send

2 xhr调用了send()方法，服务器收到了但还未响应

3 所有响应头都已被Web服务器接收到，Web服务器开始处理请求，但还没处理完

4 服务端处理完成，Http已经完全接受到了Web服务器的响应数据。

## let、var、const

var：

- 变量提升机制；在同一作用域下，变量可以在声明之前使用，值为 undefined；var在全局作用域声明的变量会挂载到window对象上，而`let const`声明的变量则不会有这一行为

let特点：

- 不存在变量提升
- 创建块级作用域：只在当前函数下声明的变量有效、在**代码块和{}括号**之内有效
- 不能重复声明 ：如果在同一个作用域中某个变量已经存在，再次使用let关键字声明的话会报错。
- 存在暂时性死区：在声明前就使用会报错，因为let定义并初始化变量语句是不会执行的，此时变量是在**暂时死区**中，JavaScript引擎在扫描代码时发现变量声明时，如果遇到`var`就会将它们提升到当前作用域的顶端，如果遇到`let或const`就会将声明放到TDZ中，如果访问TDZ中的变量就会抛出错误，只有执行完TDZ中的变量才会将它移出。

const特性：

- 同let

- 一旦初始化赋值，后面不能被修改(基本数据类型不能改变)
- const声明之后需要初始化，const声明的变量即指向其地址，修改地址会出错

1. try catch创建作用域，error仅存在catch子句中

2. eval欺骗词法作用域

3. with欺骗词法作用域

## set、map、weakMap、weakSet

**set**

- 类似于数组，但是元素不能重复
- 创建set需要通过set构造函数
- size属性可用于返回set中元素的个数
- 常用方法
  - add(value)：添加某个元素，返回set对象本身
  - delete(value)：从set中删除和这个值相等的与元素，返回boolean类型
  - has(value)：判断set中是否存在某个元素，返回boolean类型
  - clear()：清空set中所有元素，没有返回值
  - forEach(callback,[,thisArg])：同故宫forEach遍历set
  - 支持for...of

**weakset**

- 只能存放对象类型，不能存放基本类型
- 对元素的引用是弱引用，gc会回收
- weakset不能遍历
- 常用方法
  - add(value)：添加某个元素，返回weakset对象本身
  - delete(value)：从weakset中删除和这个值相等的与元素，返回boolean类型
  - has(value)：判断weakset中是否存在某个元素，返回boolean类型
- 应用场景：不能使用非构造方法创建出来的对象调用running方法

**map**

- 用于存储映射关系，对象存储映射关系只能用**字符串**作为属性名，map可以使用其他类型作为属性名
- size属性可用于返回map中元素的个数
- 常见方法
  - add(value)：添加某个元素，返回map对象本身
  - delete(value)：从map中删除和这个值相等的与元素，返回boolean类型
  - has(value)：判断map中是否存在某个元素，返回boolean类型
  - clear()：清空map中所有元素，没有返回值
  - forEach(callback,[,thisArg])：同故宫forEach遍历map
  - 支持for...of

**weakmap**

- key只能使用对象，不接受其他类型作为key
- 对元素的引用是弱引用，gc会回收
- 常见方法：
  - set(key,value)：在map中添加key，value，并且返回整个map对象
  - get(key)：根据key获取map中的value
  - has(key)：判断是否包括某一个key，返回boolean类型
  - delete(key)：根据key删除一个键值对，返回boolean类型

## Promise相关问题

promise主要解决回调函数嵌套所产生的回调地狱，将异步操作以同步操作的流程表达出来

Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。promise对象是一个构造函数，用来生成promise实例。创造promise实例后，它会立即执行。

**缺点：**

1. 无法取消promise，一旦新建立即执行，无法中途取消
2. 如果不设置回调函数，promise内部抛出的错误，不会反映到外部
3. 当处于pending状态时，无法知道当前进展到哪一阶段。是刚刚开始还是即将完成



- resolve函数的作用：将promise对象的状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
- reject函数的作用：将promise对象的状态从未完成变成失败，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去
- `then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。then方法是定义在原型对象Promise.prototype上的.它的作用是为promise实例添加状态改变时的回调函数。
  - 将传给 `then` 的函数和新 `promise` 的 `resolve` 一起 `push` 到前一个 `promise` 的 `callbacks` 数组中，达到承前启后的效果
  - 承前：当前一个 `promise` 完成后，调用其 `resolve` 变更状态，在这个 `resolve` 里会依次调用 `callbacks` 里的回调，这样就执行了 `then` 里的方法了
  - 启后：上一步中，当 `then` 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 `promise` 的 `resolve`，让其状态变更，这又会依次调用新 `promise` 的 `callbacks` 数组里的方法，循环往复。。如果返回的结果是个 `promise`，则需要等它完成之后再触发新 `promise` 的 `resolve`，所以可以在其结果的 `then` 里调用新 `promise` 的 `resolve`

当我们的`all`和`race`传入的是空数组时，会有出现什么状况呢?

- all: 感谢楼下评论的提醒，后来去看了MDN上promise.all的讲解，发现是返回一个状态是resovle的promise对象。
- race: 返回的`Promise`会一直保持在**pending**状态



在.**catch方法后**，返回的是一个**状态为fulfilled的新的promise**对象

![image-20211203134741890](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211203134741890.png)



![image-20211203134757131](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211203134757131.png)



![image-20211203134828612](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211203134828612.png)

![image-20211203134840823](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211203134840823.png)



若promise中传入的是原始数据类型，返回一个新的状态为fulfilled的新的promise对象；

在.catch方法后，返回的是一个状态为fulfilled的新的promise对象

![image-20211203135225178](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211203135225178.png)

**promise.allSettled：**

在多个`promise`同时进行时咱们很快会想到使用`Promise.all`来进行包装, 但是由于`Promise.all`的短路特性, 三个提交中若前面任意一个提交失败, 则后面的表单也不会进行提交了, 这就与咱们需求不符合.

`Promise.allSettled`跟`Promise.all`类似, 其参数接受一个`Promise`的数组, 返回一个新的`Promise`, 唯一的不同在于, 其不会进行短路, 也就是说当`Promise`全部处理完成后我们可以拿到每个`Promise`的状态, 而不管其是否处理成功.



#### 如果all、race传入空数组，会出现什么情况？

all：返回一个状态是fulfilled的promise对象

race：返回一个状态是pending的promise对象

#### promise.all中一个状态失败，仍然想执行怎么办？

![image-20211203191610383](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211203191610383.png)

将状态失败的promise通过.catch捕获，然后再调用.then方法

![image-20211203191706481](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211203191706481.png)

### 手写promise.all

特点：

1. 入参是由一个Promise实例组成的数组
2. 返回是一个promise，因为可以使用.then
3. 如果全部成功，状态变为resolved，并且返回值组成一个数组传给回调
4. 但凡有一个失败，状态变为rejected，并将error传给回调

```js
/*
	返回一个promise
	判断是否为数组
	创建空数组res作为返回值，遍历传入的数组，将结果push进res中，当长度为传入参数数组长度resolve(res)
*/
function myPromiseAll(promises){
    return new Promise((resolve,reject)=>{
		if(!Array.isArray(promises)){
			throw new Error('不是一个数组')
        }
        let result = [];
        let count = 0;
        promises.forEach((item,index)=>{
            item.then((res)=>{
                result[index] = res;
                count++;
                count === promises.length && resolve(res)
            },(err)=>[
                reject(err)
            ])
        })
    })
}
```



## async/awiat

**用同步方式，执行异步操作**。`async` 函数是 `Generator` 函数的语法糖。

用法：一个请求的结果作为下一个请求的参数，或者在几秒之后打印某个值规定的次数，有一个排队的效果

- `async`定义的函数内部会默认返回一个**`promise`**对象，所以await后面一般都接一个promise对象，如果return 一个基本类型的值，那么promise状态为`resolved`，参数是`return`的值；如果函数内部抛出异常，返回`reject`，`async`函数接收到之后，判定执行失败进入`catch`，该返回的错误打印了出来
- 如果在await中有一个promise状态为reject，那么之后的await将不在执行

**generator**:

generator函数跟普通函数在写法上的区别就是，多了一个**星号**`*`，并且只有在`generator函数`中才能使用`yield`，什么是`yield`呢，他相当于`generator函数`执行的**中途暂停点**。要继续走，使用**next方法**，`next方法`执行后会返回一个对象，对象中有`value 和 done`两个属性。

- value：暂停点后面接的值，也就是yield后面接的值
- done：是否generator函数已走完，没走完为false，走完为true

generator函数可以用`next方法`来传参，第一次next传参是没用的，只有从第二次开始next传参才有用，next传值时，要记住顺序是，先右边yield，后左边接收参数

## 浏览器事件循环

浏览器五大进程：

- 浏览器主进程

- GPU进程

  GPU（图形处理单元），开启可加速浏览器的渲染

- 插件进程

- 网络进程

- 渲染进程（当打开一个标签页输入URL后，所发起的网络请求就是从这个进程开始的）

  - GUI渲染线程
  - JS引擎线程
  - 事件触发线程
  - 定时触发线程
  - 异步http请求线程

js是单线程的，（原因：js主要用途是和用户互动和操作DOM。如果是多线程的一个线程添加DOM，一个线程删除DOM，就会出现混乱。）并且单线程意味着所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后面的任务就需要一直等待。所以推出了事件循环。把任务分为同步任务和异步任务，同步任务在主线程上执行，前面任务没执行完，后面的任务会一直等待；异步任务是在另一个任务队列里，等主线程所有任务执行完后，通知任务队列把可执行的任务放到主线程中执行。

![事件执行](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a634c9e9a32553~tplv-t2oaga2asx-watermark.awebp)



JavaScript代码执行过程中，函数执行顺序是通过**函数调用栈**确定的，还依靠**任务队列**来执行另一些代码。整个执行过程，称为事件循环。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。

### 宏任务：

script、setTimeout（timer）、setInterval、setImmediate（check）、I/O

requestanimationframe是宏任务，它的执行是跟屏幕的刷新频率相关的，一般屏幕是每秒60次的频率不断刷新屏幕的图像，每次刷新的时间大约为16.7ms，因此为了解决setTimeout定时容易引起的**丢帧**问题，才有了这个API，它可以保证每次屏幕的刷新的时候被执行一次回调函数。setTimeout，setInterval属于JS引擎，RAF属于GUI引擎

### 微任务：

process.nextTick、Promise、Async/await、MutationObserver

**MutationObserver**是HTML5新增的属性，用于监听DOM修改事件，能够监听到节点的属性、文本内容、子节点等的改动，是一个功能强大的利器。

执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

### 浏览器和Node的差异

​	**浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务**。

## 浏览器渲染

![image](https://pic4.zhimg.com/v2-5d8ee9d00bcc898318d1c9a8bf6684b7_r.jpg)

过程：

1、构建DOM树

​	字节数据 -> 字符串 -> token -> Node -> DOM 

- 浏览器从**磁盘**或者**网络**读取HTML原始字节（字节码），根据文件的指定编码（utf-8）转换为字符串
- 将字符串转换为**token**
- 生成**节点对象**并构建DOM

2、构建CSSOM树

​	css的加载不会阻塞DOM的解析，但是会阻塞DOM的渲染，会阻塞link后面js语句的执行。浏览器为了防止HTML页面的重复渲染从而降低性能，所以浏览器只会在加载的时候去解析dom树，然后在css加载完成只会才进行dom的渲染以及后面js的执行。

3、合成render Tree（渲染树）

​	渲染树中只会包含所需要显示的节点和这些节点的样式信息

4、进行布局（回流现象）

​	计算每个 DOM 元素最终在屏幕上显示的大小和位置

5、进行绘制（重绘现象）

​	绘制，本质上就是填充像素的过程。这个绘制过程是在多个层上完成的

6、合成composite

​	

### 1、渲染过程中遇到js文件怎么处理

- `CSS` 不会阻塞 `DOM` 的解析，但会阻塞 `DOM` 渲染。

- `JS` 阻塞 `DOM` 解析，但浏览器会"偷看"`DOM`，预先下载相关资源。

- 浏览器遇到 `<script>`且没有`defer`或`async`属性的 标签时，会触发页面渲染，因而如果前面`CSS`资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。（https://juejin.cn/post/6844903497599549453#heading-5）

JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

要使首屏渲染快，就不应该在首屏加载js文件，所以JS放在body底部。或者可以通过**defer**和**async**属性。

JS文件不仅会阻塞DOM的构建，也会导致CSSOM阻塞DOM的构建。

因为JS文件中可以操作DOM，也可以修改元素css样式。但是不完整的CSSOM是无法使用的，所以在js加载时，必须拿到完整的CSSOM。所以当浏览器没有完成对CSSOM的下载和构建，要执行JS脚本，浏览器将延迟脚本执行和DOM构建，直接完成CSSOM的构建和下载。

### 2、defer和async

script中的defer和async：

没有defer或者async的话：浏览器在解析 HTML 的时候，如果遇到一个没有任何属性的 script 标签，就会暂停解析，先发送网络请求获取该 JS 脚本的代码内容，然后让 JS 引擎执行该代码，当代码执行完毕后恢复解析。

**async**：**异步加载**，同步执行。当浏览器遇到带有 async 属性的 script 时，请求该脚本的网络请求是异步的，不会阻塞浏览器解析 HTML，一旦**网络请求回来**之后，如果此时 HTML 还没有**解析**完，浏览器会暂停解析，先**让 JS 引擎执行代码，执行完毕后再进行解析HTML**。在加载多个JS脚本的时候，async是无顺序的加载。

![defer2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5a89a4a1fe49ed9d5acaf25ef9aadd~tplv-k3u1fbpfcp-watermark.awebp)

defer：**延迟执行**，当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是**等待 HTML 解析完毕再执行 JS 代码**。在加载多个JS脚本的时候，defer是有顺序的加载

![script](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8313e4787f04c79838fec9961bda0fb~tplv-k3u1fbpfcp-watermark.awebp)

### 3、回流和重绘

#### 定义：

回流：当render tree中一部分（全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建

重绘：render tree中一些元素需要更新属性，这些属性只是影响元素的外观、风格，而不影响布局

**回流会导致重绘，但重绘不一定会导致回流**

#### 引起的原因：

回流：

- 元素的width、height改变
- 元素的margin、padding、border改变
- 浏览器窗口大小改变，触发clientHeight、cllientWidth改变，**resize事件**发生
- 计算offsetHeight和offsetWidth属性
- 元素的显示和隐藏
- 元素的添加和删除
- 内容变化，input框中输入文字

![image](https://pic1.zhimg.com/v2-2f40649613c8a395aba42239edfde3fc_r.jpg)

**因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘**。

#### 减少方法：

- 少用display:none;使用visibility:hidden代替，display：none会造成重排，visibility:hidden；会引起回流损失较小

- **样式集中改变**

- 如果增加元素或者clone元素，先把元素通过documentFragment放入内存中，等操作完毕后，再appendChild插入到DOM元素中

- 动画实现的速度选择，动画速度越快，回流次数越多，可以使用**requestAnimationFrame**，通过使用[DocumentFragment](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocumentFragment)创建一个`dom`碎片,在它上面批量操作Dom，操作完成之后，再添加到文档中，这样只会触发一次重排。

- 对频繁重绘或者回流的节点设置为**图层**，图层能够阻止该节点的渲染行为影响别的节点。

- 使用resize事件时，做防抖和节流处理

- 尽量在position为absolute/fixed属性的元素上加动画

- 批量修改元素时，可以先让元素脱离文档流，等修改完后，在放入文档流

- 启动GPU图像加速器

  启动GPU加速的方法：

  使用特定的css语句就可以开启，比如使用 **translate3d() rotate3d() scale3d()**　这几个方法，我们就可以使用ＧＰＵ加速了

### 4、渲染页面时常见的不良现象

**白屏问题和FOUS（无样式内容闪烁）**

FOUS：由于浏览器渲染机制（比如firefox），再CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象

#### 首屏加载白屏

首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容。

有些浏览器渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现**白屏问题**

**原因：**

1. 网络延迟
2. 资源文件体积是否过大
3. 资源是否重复发送请求去加载
4. 加载脚本的时候，渲染内容堵塞

### 5、css加载会造成阻塞吗？

css解析不会阻塞DOM树的解析，会阻塞DOM树的渲染和后面js语句的执行，js会阻塞Dom解析

#### 所以会出现**白屏现象**，怎么解 决这个问题？---->  提高css加载速度

- 使用CDN（内容分发网络）
- 对css进行压缩（使用打包工具，如webpack）
- 合理利用缓存（设置cache-control,expires,E-tag，注意文件更新后，要避免缓存带来的影响。一个解决办法就是在文件名字后面加上一个版本号）
- 减少http请求数，将多个css文件合并，或者直接写成内联样式（内联样式不能缓存）

##  DOMContentLoaded 与 load 的区别 

- 当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。我们前面提到 **CSS 加载会阻塞 Dom 的渲染和后面 js 的执行,js 会阻塞 Dom 解析**,所以我们可以得到结论:
  当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。

- 当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。

**浏览器加载页面两个事件：**

两个事件：**onLoad**和**DOMContentLoaded**

**onLoad**：页面中所有资源都被加载完才会执行（包括css，图片，js等）

**DOMContentLoaded**：就是当页面的**内容解析完成**后，则触发该事件

1. 如果页面中同时存在css和js，并且存在**js在css后面**，则DOMContentLoaded事件会在css加载完后才执行。
2. 其他情况下，DOMContentLoaded都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。

## 计算白屏时间和首屏时间

### 白屏时间

**白屏时间**指的是浏览器开始显示内容的时间。我们通常认为浏览器开始渲染 `<body>` 标签或者解析完 `<head>` 标签的时刻就是页面白屏结束的时间点。

可使用 Performance API 时

```
白屏时间 = firstPaint - performance.timing.navigationStart;
```

不可使用 Performance API 时

```
白屏时间 = firstPaint - pageStartTime;
```

### 首屏时间

**首屏时间**是指用户打开网站开始，到浏览器首屏内容渲染完成的时间。对于用户体验来说，首屏时间是用户对一个网站的重要体验因素。通常一个网站，如果首屏时间在5秒以内是比较优秀的，10秒以内是可以接受的，10秒以上就不可容忍了。超过10秒的首屏时间用户会选择刷新页面或立刻离开。

通常计算首屏的方法有

- 首屏模块标签标记法
- 统计首屏内加载最慢的图片的时间
- 自定义首屏内容计算法



## 字符串转数组

1. Array.from(str)
2. [...str]
3. str.split("")

## 数组转字符串

1. array.toString()
2. array.toLocalString()
3. array.join()
4. String(array)

## JavaScript语法解析

JavaScript是解释型语言，通过词法分析-》语法分析-》语法树，开始解释执行了。

1. 词法分析：将字符流转换为记号流（代码转换为token）
2. 语法分析：将token转换为AST树（type、body、children、declaration）
3. 预编译：当JavaScript引擎解析脚本时，它会在预编译期对所有声明的变量和函数进行处理！并且是先预声明变量，再预定义函数。预编译分为全局预编译和函数预编译。预编译会创建当前环境的执行上下文。
   - 函数预编译四部曲：
     - 创建AO
     - 找形参和变量声明，作为AO的属性名，值为undefined
     - 将实参和形参相统一
     - 找函数声明，将函数名作为AO对象的属性名，值赋予函数体
4. 解释执行，在执行过程中，JavaScript 引擎是严格按着作用域机制（scope）来执行的，并且 JavaScript 的变量和函数作用域是在定义时决定的，而不是执行时决定的。JavaScript 中的变量作用域在函数体内有效，无块作用域；

![image-20211212160355254](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211212160355254.png)

![image-20220102165253953](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220102165253953.png)

## axios和ajax的区别

- axios是通过promise实现对ajax的封装，提供一些而ajax实现了网页的局部数据刷新
- axios从 node.js 创建 http 请求
- 支持请求响应拦截器
- 自动转换json数据
- 客户端支持防止CSRF

## type、interface区别

相同

- 1. 都可以描述一个对象或者函数
- 2. 都允许拓展（extends）


不同

- 1. type 可以声明基本类型别名，联合类型，元组等类型
- 2. interface 能够声明合并

## 图片懒加载

InterSectionObserver

这是浏览器内置的一个`API`，实现了`监听window的scroll事件`、`判断是否在视口中`以及`节流`三大功能。

```txt
IntersectionObserverEntry对象
callback函数被调用时，会传给它一个数组，这个数组里的每个对象就是当前进入可视区域或者离开可视区域的对象(IntersectionObserverEntry对象)
这个对象有很多属性，其中最常用的属性是：

target: 被观察的目标元素，是一个 DOM 节点对象
isIntersecting: 是否进入可视区域
intersectionRatio: 相交区域和目标元素的比例值，进入可视区域，值大于0，否则等于0
```

代码实现

```js
let img = document.document.getElementsByTagName("img");
const observer = new IntersectionObserver(changes => {
  //changes 是被观察的元素集合
  for(let i = 0, len = changes.length; i < len; i++) {
    let change = changes[i];
    // 通过这个属性判断是否在视口中
    if(change.isIntersecting) {
      const imgElement = change.target;
      imgElement.src = imgElement.getAttribute("data-src");
      observer.unobserve(imgElement);
    }
  }
})
observer.observe(img);
```

vue写法

```js
/**
 * 判断元素可见
 */
function isVisible(el){
  let windowHeight = window.innerHeight
  let position = el.getBoundingClientRect()
  // 当元素的top偏移量小于页面大小并且大于高度的负数
  if(position.top<windowHeight && position.top>-position.height){
    return true
  }
  return false
}

/**
 * 对图片进行懒加载
 */
function lazyLoad(img, src){
  if(img && src && isVisible(img)){ // 元素存在，元素未被加载，元素可见
    setTimeout(function(){
      img.setAttribute('src', src)
    }, 1000) // 模拟网络请求慢的情况
  }
}

export default {
  install(Vue, options){
    Vue.directive('lazy', {
      bind: function(el, binding, vnode){
        el.setAttribute('src', options.loading)
        window.addEventListener('scroll', function(){
          lazyLoad(el, binding.value)
        })
      },
      inserted: function(el, binding, vnode){
        lazyLoad(el)
      }
    })
  }
}
```

### 自定义指令

根据指令的写法，我们需要用到两个钩子函数：

1. inserted：在绑定了该指令的图片被插入后，获取当前图片元素—— `el` 和 绑定的信息 —— `binding`。需要处理逻辑包括：

2. 1. 将占位图赋值给当前图片
   2. 通过 `binding.arg` 获取到指令参数 —— 图片容器的**「className」**，然后找到父容器
   3. 构建当前图片对应的图片信息对象img，包括：el（图片元素），src（图片原地址），containerClientHeight（图片容器的clientHeight值），并将**「img」**添加到**「imgs」**中。
   4. 立即处理当前图片是否需要加载和渲染 —— **「loadImg」**（这部分逻辑在单独函数里维护，后边详细讲）

3. unbind：在图片指令解除绑定后，将图片从带加载的图片集合imgs里清除。

## JavaScript使浏览器不缓存

当浏览器要访问一个某个资源时，浏览器会通过资源的URL来判断是否读取缓存中的内容。由于浏览器存在缓存，所以会导致服务器上的内容修改了，但是在浏览器却显示没有变化。

为了解决这个问题，可以在每次请求的时候加一个**随机数参数**或者**时间戳**。它的作用就是让浏览器误以为请求的是一个新链接，这样浏览器就不会去读取缓存里的内容。

```js
head->meta
<!--设置过期时间设置0为直接过期并清除缓存-->
<meta http-equiv="Expires" content="0">
<!--设置不缓存页面-->
<meta http-equiv="Pragma" content="no-cache">
<!--设置不修改消息存储-->
<meta http-equiv="Cache-control" content="no-cache">
<!--同上-->
<meta http-equiv="Cache" content="no-cache">
```

## F5和Ctrl+F5刷新

F5触发浏览器缓存，http请求头中包含If-Modified-Since或者If-None-Match字段，返回304状态码，F5只对当前页面进行刷新，只刷新本地缓存；

Ctrl+F5触发的请求头中有Pragma: no-cache 或 Cache-Control: no-cache 字段，返回200状态码，会把；浏览器中的临时文件夹的文件删除再重新从服务器下载。

# Jquery和Vue的区别

jquery：直接操作DOM获取元素，使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作

Vue：视图和数据分离，对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定，这就是MVVM。

# Vue

## v-model

Vue内部的`v-model`是完成**事件绑定** 和**事件监听** 的语法糖。父组件中进行数据绑定，在子组件中触发事件后并修改对应数据即可。

在Vue中，我们可以使用`v-bind`实现单项的数据绑定，也就是通过**父组件向子组件传入数据** ，但是反过来，**子组件不可以修改父组件传递过来的数据** ，这也就是所谓的单向数据绑定。

而`v-model`就实现了双向数据绑定，实际上它就是通过Vue提供的事件机制。即在子组件通过`$emit()`触发一个事件，在父组件使用`v-on`来监听对应的事件并修改相应的数据。

```js
<input type="text" :value="name" @input="name = $event.target.value">
```



## vue内置指令

![image-20220301111837488](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220301111837488.png)

## 生命周期

1. beforecreate：组件实例被创建前。此阶段data、methods、computed、watch上的方法和数据不能被访问。
2. created: 组件实例创建完成。在这一步，实例已完成以下配置：数据观测，属性和方法的运算。这里没有挂载$el，如果想要和DOM进行交互，可以通过vm.$nextTick来访问DOM。
3. beforemount: 组件挂载前。在挂载开始之前被调用：相关的render函数首次被调用
4. mounted: 组件挂载完成。在挂载完成后发生，在当前阶段，真实的dom挂载完毕，数据完成双向绑定，可以访问到dom节点
5. beforeUpdate: 更新前。数据更新时调用，发生在虚拟dom重新渲染和patch之前，可以在这个钩子中进一步更改状态，这不会触发附加的重渲染过程
6. Updated: 更新完成。
7. beforedestory: 销毁前。在这一步实例仍然完全可用。我们可以在这是进行善后首位工作，比如清除定时器。
8. destoryed: 销毁完成。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。

**异步请求在钩子函数created，beforeMount，mounted中进行异步请求，这三个钩子函数中data已经创建，可以将服务端返回的数据进行赋值**

如果异步请求不需要依赖dom，推荐在**created**钩子函数中调用异步请求，因为在create钩子函数中调用异步请求有一下优点：

- 能更快的获取到服务端数据，减少页面loading事件
- ssr——服务端渲染不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

**数据请求在created和mouted的区别**：

`created`是在组件实例一旦创建完成的时候立刻调用，这时候页面`dom`节点并未生成`mounted`是在页面`dom`节点渲染完毕之后就立刻执行的触发时机上`created`是比`mounted`要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在`mounted`请求有可能导致页面闪动（页面`dom`结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在`create`生命周期当中



**父子组件生命周期：**

**创建阶段：**

父beforeCreate -> 父create -> 父beforeMount -> 子beforeCreate -> 子create -> 子组件beforeMount -> 子mounted -> 父mounted 

**运行阶段：**

父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated

**销毁阶段：**

父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destoryed

## data是一个函数

组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就返回一份新的data，类似于给每个组件实例创建了一个私有的数据空间，让各个组件实例维护各自的数据。单纯携程对象形式，使得所有组件实例共用了一份data，会造成一个变了全都变了的结果。

如果不用function 函数返回，每个组件的data 都是内存的同一个地址，如果两个实例同时引用一个对象,那么当你修改其中一个属性的时候,另外一个实例也会跟着改。而两个实例应该有自己各自的域才对。javascipt只有函数构成作用域(注意理解作用域，只有函数的{}构成作用域，对象的{}以及 if(){}都不构成作用域)。data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响。

获取data的初始值：this.$option方法   `this.$options.data.call(this)`

在data里定义不可修改的值：用Object.freeze()冻结

## 双向数据绑定

![image-20211127162643985](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127162643985.png)



Vue中数据双向绑定的步骤，流程大致可以分为两个阶段：一个是**初始化阶段**，一个是**数据更新阶段**

### 初始化阶段

执行new Vue() ，Vue进入初始化阶段 ,此时开始两个操作，一个是**数据监听**，一个是**页面渲染**。

一方面 Vue 会遍历 data 选项中的属性，并用 **Object.defineProperty** 将它们转为 **getter/setter**，实现依赖。收集和响应式。

另一方面，指令编译器Compile 对元素节点的指令进行扫描和解析，**初始化视图**，并**订阅 Watcher** 来更新视图。此时wacher 会将自己添加到消息订阅器中(Dep)，初始化完毕。

### 数据更新阶段

当data数据中有属性发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用**Dep.notify()**，随后Dep 开始遍历所有的订阅者，对订阅者Watcher**发送通知**，并且会调用订阅者的 **update 方法**，最后，订阅者Watcher收到Dep的数据**更新的通知**后，也会对视图进行相应的**更新**

### 实现：

```js
//数据劫持（Observer）
class Observer {
    constructor(data) {
        this.observer(data)
    }
    observer(data) {
        //要对这个data数据原有的属性改成set和get的形式
        if (!data || typeof data !== 'object') { //如果数据不存在或者不是对象
            return;
        }
        //要将数据一一劫持，先获取到data的key和value
        Object.keys(data).forEach(key => { //该方法是将对象先转换成数组，再循环
            //劫持(定义一个函数，数据响应式)
            this.defineReactive(data, key, data[key]);
            //深度递归劫持，这里的递归只会为初始的data中的数据进行劫持（添加set和get方法），如果在defineReactive函数中使用set新增加则不会进行劫持
            this.observer(data[key]);
        })
    }
    //定义响应式
    defineReactive(obj, key, value) {
        //在获取某个值的时候，可以在获取或更改值的时候，做一些处理
        let that = this;
        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get() { //当取值时，调用的方法
                return value;
            },
            set(newValue) { //当给data属性中设置值的时候，更改获取的属性的值
                if (newValue !== value) {
                    console.log(this, 'this'); //这个this指向的是被修改的值
                    //但是这里的this不是Observer的实例,所以需要在最初保存一下当前this指向
                    that.observer(newValue); //如果是对象继续劫持
                    value = newValue;
                }
            }
        })
    }

    /**
     * 以上就实现了数据劫持
     */
}


//observer.js
/**
 * 发布订阅
 */
class Dep {
    constructor() {
        //订阅的数组
        this.subs = [];
    }
    //添加订阅者
    addSub(watcher) {
        this.subs.push(watcher);
    }
    //通知
    notify() {
        this.subs.forEach(watcher => {
            watcher.update()
        })
    }
}
```

## computed和watch

1. 计算数组可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，return返回计算之后的结果，结果会被缓存，如果依赖项不变时不会重新计算。侦听器**可以侦测某个响应式数据的变化并执行副作用**，常见用法是传递一个函数，执行副作用，`watch`没有返回值，但可以执行**异步**操作等复杂逻辑。
2. 计算属性场景是**简化**行内模板中的复杂表达式，模板中出现太多逻辑会使模板变得臃肿不易维护。侦听器常用场景是状态变化之后做一些额外的`DOM`操作或者异步操作。选择采用何种方案时首先看是否需要派生出新值，基本能用计算属性实现的方式首选计算属性。
3. vue3中watch选项发生了一些变化，例如不再能侦测一个点操作符之外的字符串形式的表达式；reactivity API中新出现了`watch、watchEffect`可以完全替代目前的watch选项，且功能更加强大。

**computed**：

vue 在创建 computed 属性时候，会循环所有计算属性，每一个计算属性会创建一个 watch，并且在通过 `defineProperty` 定义监听，在 get 中，计算属性工作是做依赖收集，在 set 中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为 computed 是懒执行，也就是说第一次初始化之后，便不会执行计算，下一次变更执行重新计算是在 set 中。

## 虚拟DOM

​	虚拟 `DOM` 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 `DOM` 的动作，虚拟 `DOM` 不会立即操作 `DOM`，而是将这 10 次更新的 `diff` 内容保存到本地一个 `JS` 对象中，最终将这个 `JS` 对象一次性 `attch` 到 `DOM` 树上，再进行后续操作，避免大量无谓的计算量。所以，用 `JS` 对象模拟 `DOM` 节点的好处是，页面的更新可以先全部反映在 `JS` 对象(虚拟 `DOM` )上，操作内存中的 `JS` 对象的速度显然要更快，等更新完成后，再将最终的 `JS` 对象映射成真实的 `DOM`，交由浏览器去绘制。

## Vue的响应式原理

**通过数据的改变去驱动dom视图的变化**

数据劫持+观察者模式

**vue2**

对象内部通过defineReactive方法，使用object.defineProperty将属性进行劫持（只会劫持已经存在的属性）。数组则是通过重写数组方法进行实现。当页面使用对应属性时，每个属性都拥有自己的dep属性，存放其依赖的watcher（依赖手机），当属性变化后会通知自己对应的watcher去更新

vue不会触发视图更新：

1. 在实例创建之后新的属性到实例上
2. 直接更改数组下标来修改数组的值

当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪，然后会触发对象————__ob__j的dep收集到的watcher去更新，当修改数组索引时我们调用数组本身的splice方法去更新数组

**vue3**使用proxy重写了响应式系统，将响应式系统抽成了reactivity模块，使其可以单独使用。并且使用composition API ，通过reactive手动将数据设置为响应式的。reactive函数内部使用Proxy将传入的函数进行代理。Proxy可以检测到对象上对所有属性的修改操作。对于基础数据类型可以通过ref API处理问题。vue3的**依赖收集**是当访问对象属性时，触发get函数，其中会调用一个track函数，每个对象的key维护一个depset,将当前激活的effect函数（数据变化后执行的副作用函数）放到对应的一个dep中进行依赖收集。当对象属性发生更新时，就会触发set函数，调用trigger函数通过target和key拿到依赖收集阶段的effect函数集合，将其放入待执行的队列，执行函数，从而达到**派发通知**。



## vue如何监听数组的变化

vue2.0对响应式数据的实现有一些不足：

- 无法检测数组/对象的新增

> Vue检测数据的变动是通过Object.defineProperty实现的，所以无法监听数组的添加操作是可以理解的，因为是在构造函数中就已经为所有属性做了这个检测绑定操作。

- 无法检测通过索引改变数组的操作

Object.defineProperty是可以检测到通过索引改变数组的操作的，vue2.0没有实现

1. 通过watch监听，deep属性可以深度监听

2. vue.set()  或者this.$set

### Vue 是怎么实现数组的响应式

vue重写了数组原型上的方法，在重写的方法中触发了更新，'push',  'pop',  'shift',  'unshift',  'splice',  'sort',  'reverse'

**重写方法会使所有数组都受到影响吗？vue怎么解决？**



## v-show和v-if

v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。

v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none），无论条件真假，都会渲染

v-show由false转为true时不会触发组件的生命周期

v-if由false转为true的时候，触发组件的`beforeCreate`、`create`、`beforeMount`、`mounted`钩子，由`true`变为`false`的时候触发组件的`beforeDestory`、`destoryed`方法

**使用场景**

v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景

v-show 适用于需要非常频繁切换条件的场景

**display:none、visibility:hidden 和 opacity:0 之间的区别？**

1、子元素是否继承：visibility、opacity可以继承

2、是否占据空间：visibility、opacity占据空间

3、事件绑定：opacity:0有效

4、过渡动画transition：opacity:0;有效

![image](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/618888ae9baa4c3096479b1f61bb37f3~tplv-k3u1fbpfcp-watermark.awebp)

## diff算法

![image](E:\vue\diff算法.png)

![截屏2021-08-08 上午11.49.38.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-watermark.awebp)

https://juejin.cn/post/6994959998283907102#heading-10

patch方法：

对比当前同层的虚拟节点是否为同一种类型的标签：

判断其是否是同一类型的标签的标准：

key值是否一样；标签名是否一样；是否都为注释节点；是否都定义了data；当标签是input时，type是否相同；

- 是：继续执行patchNode方法：

  - 找到对应的真实dom，称为el

  - 判断newNode和oldnode是否指向同一个对象，如果是，直接return

  - 如果他们都有文本节点并且不相等，那么直接将el的文本节点设置为newVnode的文本节点

  - 如果oldVnode有子节点而newVnode没有，则删除el的子节点

  - 如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el

  - 如果两者都有子节点，则执行updateChildren函数比较子节点

    updateChildren方法：新的子节点集合和旧的子节点的集合各有首尾两个指针

    新旧节点首尾进行四次比较，如果四次都匹配不到，则将所有旧子节点的key做一个映射到旧节点下标的key=>index表，然后用新vnode的key去找出旧节点中可以复用的位置

- 否：没必要比对，直接整个节点替换成新虚拟节点

**对比vue3**

在Vue2.0当中，当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。但这比较的过程是全量的比较，也就是每个节点都会彼此比较。但其中很显然的是，有些节点中的内容是不会发生改变的，那我们对其进行比较就肯定消耗了时间。所以在Vue3.0当中，就对这部分内容进行了优化：在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个**静态标记**。那么之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。

在 Vue3 里 `updateChildren` 为

- 头和头比
- 尾和尾比
- 基于最长递增子序列进行移动/添加/删除

看个例子，比如

- 老的 children：`[ a, b, c, d, e, f, g ]`
- 新的 children：`[ a, b, f, c, d, e, h, g ]`

1. 先进行头和头比，发现不同就结束循环，得到 `[ a, b ]`
2. 再进行尾和尾比，发现不同就结束循环，得到 `[ g ]`
3. 再保存没有比较过的节点 `[ f, c, d, e, h ]`，并通过 newIndexToOldIndexMap 拿到在数组里对应的下标，生成数组 `[ 5, 2, 3, 4, -1 ]`，`-1` 是老数组里没有的就说明是新增
4. 然后再拿取出数组里的最长递增子序列，也就是 `[ 2, 3, 4 ]` 对应的节点 `[ c, d, e ]`
5. 然后只需要把其他剩余的节点，基于 `[ c, d, e ]` 的位置进行移动/新增/删除就可以了

文本节点：1              class：2 				style：4

## vue3新特性

https://juejin.cn/post/6940454764421316644#heading-16

- setup()

  setup 是 Vue3.x 新增的一个选项， 他是组件内使用 `Composition API`的入口。setup 执行时机是在 beforeCreate 之前执行。

  它接受两个参数：

  - props: 组件传入的属性

    setup 中接受的`props`是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以**不可以使用 ES6 解构**，解构会消除它的响应式。

  - context

    `setup`中不能访问 Vue2 中最常用的`this`对象，所以`context`中就提供了`this`中最常用的三个属性：`attrs`、`slot` 和`emit`，分别对应 Vue2.x 中的 `$attr`属性、`slot`插槽 和`$emit`发射事件。并且这几个属性都是自动同步最新的值，所以我们每次使用拿到的都是最新值。

- 生命周期

  Vue3.0 新增了`setup`，然后是将 Vue2.x 中的`beforeDestroy`名称变更成`beforeUnmount`; `destroyed` 表更为 `unmounted`

  ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eadd1ec0ac94343951ae2453cf41fce~tplv-k3u1fbpfcp-watermark.awebp)

- 响应式

  **reative**

  reative中定义的对象单独访问比较麻烦，用解构的话会消除它的响应式，所以用toRefs来解决，toRefs 用于将一个 reactive 对象转化为属性全部为 ref 对象的普通对象。

  ```js
  const user = reactive({ nickname: "xiaofan", age: 26, gender: "女" });
   return {
        // 使用reRefs
        ...toRefs(user),
      };
  ```

  

  **ref、toRef、toRefs**

  `ref` 就当作简单的响应式变量； `toRef` 就是把不是响应式的对象转化成响应式； `toRefs` 就是把响应式的reactive对象，分解成无数的响应式 ref

- 片段（Fragment）

  在 Vue2.x 中， `template`中只允许有一个根节点；但是在 Vue3.x 中，你可以直接写多个根节点。

- Teleport使用

  **希望继续在组件内部使用`Dialog`, 又希望渲染的 DOM 结构不嵌套在组件的 DOM 中**。 此时就需要 Teleport 上场，我们可以用`<Teleport>`包裹`Dialog`, 此时就建立了一个传送门，可以将`Dialog`渲染的内容传送到任何指定的地方。

  例子：使用 `teleport` 组件，通过 `to` 属性，指定该组件渲染的位置与 `<div id="app"></div>` 同级，也就是在 `body` 下，但是 `Dialog` 的状态 `dialogVisible` 又是完全由内部 Vue 组件控制.

- 自定义指令

  ```js
  const { createApp } from "vue"
  
  const app = createApp({})
  app.directive('focus', {
      mounted(el) {
          el.focus()
      }
  })
  
  ```

- ref

  ref底层会通过 `new RefImpl()`来创造ref数据，在`new RefImpl()`会首先给数据添加`__v_isRef`只读属性用来标识`ref`数据。而后判断传入的值是否是对象，如果是对象则使用`toReactive()`处理成`reactive`，并将值赋给`RefImpl()`的`value`属性上。在`访问`和`设置`ref数据的`value`时会分别触发`依赖收集`和`派发更新`流程。

  `toReactive()`中会先判断传入的值是不是一个对象，如果是对象则使用`reactive`进行处理，不是则直接返回值本身。

  - 为什么已经有了`reactive`还需要在设计一个`ref`呢？

     因为vue3响应式方案使用的是`proxy`，而`proxy`的代理目标必须是非原始值，没有任何方式能去拦截对`原始值`的操作，所以就需要一层对象作为包裹，间接实现原始值的响应式方案。

  - 为什么`ref`数据必须要有个`value`属性，访问ref数据必须要通过`.value`的方式呢

    

## Vue2对比vue3

1. 生命周期变化

   setup()代替

2. 使用proxy代替defineProperty()

   vue2检测不到对象属性的添加和删除，对数组对象的深层监听无法实现，因为组件每次渲染都是将data里的数据通过`defineProperty`进行响应式或者双向绑定上，之前没有后加的属性是不会被绑定上，也就不会触发更新渲染。需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题。

   **vue3**使用proxy重写了响应式系统，将响应式系统抽成了reactivity模块，使其可以单独使用。并且使用composition API ，通过reactive手动将数据设置为响应式的。reactive函数内部使用Proxy将传入的函数进行代理。Proxy可以检测到对象上对所有属性的修改操作。对于基础数据类型可以通过ref API处理问题。

   `Proxy`的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了。`Proxy`需要的是整体，不需要关心里面有什么属性，而且`Proxy的配置项有13种`，proxy的话除了`IE`，其他浏览器都兼容，`vue2.x`之所以只能兼容到IE8就是因为`defineProperty`无法兼容IE8

3. Diff算法

   vue3:

   - 事件缓存：将事件缓存，可以理解为变成静态的了

     比如说一个click事件，vue3编译时，onClick 会先读取缓存，如果缓存没有的话，就把传入的事件存到缓存里，也就相当于变成静态节点了。

   - 添加静态标记：Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff

   - 静态提升：创建静态节点时保存，后续直接复用

   - 使用最长递增子序列优化了对比流程：Vue2 里在 updateChildren() 函数里对比变更，在 Vue3 里这一块的逻辑主要在 patchKeyedChildren() 函数里，具体看下面

   

4. 打包体积变化

   vue2中，依赖包和框架特性的增多，有时候不必要的，未使用的代码文件都被打包了进去，所以后期项目大了，打包文件会特别多还很大。

   在`Vue 3`中，`module bundler`（模块打包）能够静态地分析模块依赖关系，并删除与未使用的`module.exports`属性相关的代码。模板编译器还生成了对树抖动友好的代码，只有在模板中实际使用某个特性时，该代码才导入该特性的帮助程序。

5. 支持ts

## 为什么key不为index和随机数

举例：

li列表[a,b,c]->[d,a,b,c]插入一项，会发现所有的标签都重新渲染了，在进行子节点的 `diff算法` 过程中，会进行 旧首节点和新首节点的`sameNode`对比，这一步命中了逻辑，因为现在`新旧两次首部节点` 的 `key` 都是 `0`了，同理，key为1和2的也是命中了逻辑，导致`相同key的节点`会去进行`patchVnode`更新文本，而原本就有的`c节点`，却因为之前没有key为4的节点，而被当做了新节点，所以使用index做key，最后新增的居然是本来就已有的c节点。

1. 节点顺序颠倒（reverse）
2. 节点删除

![image-20211127162031862](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211127162031862.png)

如果不存在对数据的逆序添加或删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。

用随机数的话，新节点的key在旧节点key生成的key->index映射表中不会找到，会新创建元素节点，创键完后，把旧节点删除

例如：`123` -> 前面重新创建三个子组件 -> `321123` -> 删除、销毁后面三个子组件 -> `321`。

### 有key的优点：

在diff算法操作可以更加准确和快速。

**更准确**：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。

**更快速**：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快

## vue组件通信

**父子组件通信**

props和$emit，$parent和$child，provide和inject，ref，$attrs/$listeners

**兄弟组件通信**

eventBus(不适合多人开发)、vueX

**跨级组件通信**

provide和inject、$attrs/$listeners、eventBus、vuex



### **props 和$emit**

prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。

**优点:**

`props`传递数据优点是显而易见的，灵活简单，可以对`props`数据进行计算属性，数据监听等处理。父子组件通信灵活方便。这里可能单单仅限父子一层。

**缺点：**

子组件虽然不能直接对父组件`prop`进行重新赋值，但是当父组件是引用类型的时候，子组件可以修改父组件的`props`下面的属性。

**使用场景：**

```txt
**在父组件的created中发请求获取数据，通过prop传递给子组件。子组件在created或者mounted中拿父组件传递过来的数据** 这样处理是有问题的。

在父组件调用接口传递数据给子组件时，接口响应显然是异步的。这会导致无论你在父组件哪个钩子发请求，在子组件哪个钩子接收数据。都是取不到的。当子组件的mounted都执行完之后，此时可能父组件的请求才返回数据。会导致，从父组件传递给子组件的数据是undefined。
```

方法一：

​	在渲染子组件的时候加上一个条件,data1是父组件调用接口返回的数据。当有数据的时候在去渲染子组件。这样就会形成天然的阻塞。在父组件的created中的请求返回数据后，才会执行子组件的created，mounted。最后执行父组件的mounted。

	<children v-if="data1" :data="data1" ></children>
方法二：

​	在子组件中 watch 监听，父组件获取到值，这个值就会变化，自然是可以监听到的

```js
props:['data1'],
watch:{
    data1:{
      deep:true,
      handler:function(newVal,oldVal) {
        this.$nextTick(() => {
          this.data1 = newVal
          this.showData1(this.data1)
        })
      }
    },
}
```



### **provide/inject**

父组件中通过`provide`来提供变量, 然后再子组件中通过`inject`来注入变量。provide 和 inject 主要为高阶插件/组件库提供用例。

注意: 这里不论子组件嵌套有多深, 只要调用了`inject` 那么就可以注入`provide`中的数据。**provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。**

实现响应式的方法：

1. 在父组件provide祖先组件的实例，然后在子孙组件中注入依赖；

```js
 provide() {
    return {
      theme: this//方法一：提供祖先组件的实例
    };
  },
```

2. 使用2.6最新API Vue.observable 优化响应式 provide(推荐)

```js
provide() {
   this.theme = Vue.observable({
     color: "blue"
   });
   return {
     theme: this.theme
  };
},
```

子组件中：

```js
 inject: {
    theme: {
      //函数式组件取值不一样
      default: () => ({})
    }
  }
```



### **ref/refs**

`ref`：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据:        通过this.$refs.comA获取子组件实例

### **eventBus**

初始化 -> 发送事件$emit -> 接收事件$on -> 移除事件监听者$off

### **$attrs和$listeners**

隔代通信

1. 使用`props`绑定来进行一级一级的信息传递, 如果D组件中状态改变需要传递数据给A, 使用事件系统一级级往上传递。
2. 使用`eventBus`,这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低。
3. 使用Vuex来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理,使用Vuex处理感觉有点大材小用了。

解决以上问题，采用$attrs和$listeners





## 事件总线---eventBus-----------未完成

```js

```



## vue-router hash和history实现原理

### hash：

通过监听location对象hash值变化事件来实现的；hash的URL中有#。即地址栏URL中的#符号。比如这个URL：http://www.abc.com/#/hello，hash的值为#/hello。它的特点在于：hash虽然出现在URL中，但不会被包括在HTTP请求中，对后台完全没有影响，因此改变hash**不会重新加载页面**。

当一个页面的hash发生了改变，便会触发**hashchange**事件，也就因此，我们可以通过window.**onhashchange**

监听hash的变化，来进行页面的更新处理。

### history:

依赖H5 history API实现前端路由，路由地址和正常的URL一样，初次访问和刷新都会向服务器发送请求，如果没有请求到对应资源会返回404，所以路由地址匹配不到任何资源的时候，应该返回同一个index.html页面，需要在nginx中配置。(去除URL中的#，用history模式) 在nginx配置项中，添加`try_files $uri $uri/ /index.html;`，注意文件的路径，打包完的js路径改为绝对路径。

```js
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

利用了HTML5 History Interface中新增的pushState（）和replaceState（）方法。（需要特定浏览器支持）

这两个方法应用于浏览器的历史记录栈，在当前已有的back、forward、go的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的URL，但浏览器不会立即向后端发送请求。

因此可以说，hash模式和history模式都属于浏览器自身的特性，Vue-Router只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。

通过**popstate**来监听事件

popState事件：当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。

需要注意的是调用`history.pushState()`或`history.replaceState()`不会触发`popstate`事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用`history.back()`或者`history.forward()`方法）



[Nginx配置](https://juejin.cn/post/6844903856359342087)

**前端：**

我们用nginx部署项目，然后在地址栏输入`http://localhost:8080`（这里配置的端口是8080），你会发现地址栏之后会变为`http://localhost:8080/home`，并且看起来一切正常，似乎路由也可以正常切换而不会发生其他问题（实际上会发生问题，后面会进行讨论）。看起来好像不需要按官网告诉我们的那样配置后端也能实现`history`模式，但如果你直接在地址栏输入`http://localhost:8080/home`，你会发现你获得了一个404页面。

那么`http://localhost:8080`为什么可以（部分）正常显示呢？道理其实很简单，你访问`http://localhost:8080`时，**静态服务器（这里是nginx）会默认去目标目录**（这里为`location`中`root`所指定的目录）下寻找**`index.html`**（这是nginx在端口后没有额外路径时的默认行为），**目标目录**下有这个文件吗？有！然后静态服务器返回给你这个文件，配合**vue-router**进行转发，自然可以（部分）正常显示。
 但如果直接访问`http://localhost:8080/home`，静态服务器会去目标目录下寻找`home`文件，目标目录下有这个文件吗？没有！所以自然就404了。

**后台：**

对后台进行nginx配置

在传统的`hash`模式中（`http://localhost:8080#home`），即使不需要配置，静态服务器始终会去寻找`index.html`并返回给我们，然后`vue-router`会获取`#`后面的字符作为参数，对前端页面进行变换。

类比一下，在`history`模式中，我们所想要的情况就是：输入`http://localhost:8080/home`，但最终返回的也是`index.html`，然后`vue-router`会获取`home`作为参数，对前端页面进行变换。那么在nginx中，谁能做到这件事呢？答案就是`try_files`。它会按照try_files**后面的参数**依次去**匹配`root`中对应的文件或文件夹**。如果匹配到的是一个文件，那么将返回这个文件；如果匹配到的是一个文件夹，那么将返回这个**文件夹中`index`指令指定的文件**。

## 路由导航守卫

**全局、单个路由独享、组件级**

### **全局**

router.beforeEach 全局前置守卫，进入路由前

router.beforeResolve 全局解析守卫，在beforeRouteEnter之后调用

router.afterEach 全局后置钩子，进入路由之后

**三个参数**：

to：将要进入的**路由对象**（路由对象：平时通过this.$route获取到的对象）

from：将要离开的路由对象

next：是一个函数，必须调用，否则不能进入路由。next()进入该路由，跳转新路由：next('path地址')或者next({path:''})，next({name:''})

### 路由独享守卫

beforeEnter:(to,from,next)=>{

​	//调用顺序在全局前置守卫后面

}

### 路由组件内守卫

beforeRouteEnter 进入路由前，在路由独享守卫后调用 **不能**获取组件实例 `this`，组件实例还没被创建，可以通过传一个回调给`next`来访问组件实例 。

```js
    beforeRouteEnter (to, from, next) {
    console.log('在路由独享守卫后调用');
      next(vm => {
        // 通过 `vm` 访问组件实例`this` 执行回调的时机在mounted后面，
      })
    }

```

beforeRouteUpdate 路由复用同一个组件时，在当前路由改变，但是该组件被复用时调用，可以访问组件实例this

beforeRouteLeave 离开当前路由时

## axios请求响应拦截

在 `axios` 对象上有一个 `interceptors` 对象属性，该属性又有 `request` 和 `response` 2 个属性，它们都有一个 `use` 方法，`use` 方法支持 2 个参数，第一个参数类似 `Promise.then` 的 `resolve` 函数，第二个参数类似 `Promise.then` 的 `reject` 函数。我们可以在 `resolve` 函数和 `reject` 函数中执行同步代码或者是异步代码逻辑。

```js
// 添加一个请求拦截器
axios.interceptors.request.use(function (config) {
  // 在发送请求之前可以做一些事情、判断token是否过期
  return config;
}, function (error) {
  // 处理请求错误
  return Promise.reject(error);
});

// 添加一个响应拦截器
axios.interceptors.response.use(function (response) {
  // 处理响应数据
  return response;
}, function (error) {
  // 处理响应错误
  return Promise.reject(error);
});
```

## vue跳转传参问题

1. router-link
2. this.$router.push()
3. this.$router.replace()
4. this.$router.go(n)

### 带参数跳转（刷新页面参数是否消失）

可以通过**path**和**name**实现路由跳转

```js
this.$router.push('/index')
this.$router.push({name:'index'})
this.$router.push({path:'/index'})
```

可以通过**params传参**和**query传参**两种方式

### params传参

$route.push的**path携带参数方式**（**路由配置中指定参数**）

```js
// 路由配置，在router.js
{ 
   path: '/index/:id',  //若id后面加?代表这个参数是可选的，即使不传id也不会导致页面无法访问
   name: 'index', 
   component: ()=>import('@/components/router/Index.vue') },
}

// 列表中跳转，在方法中调用
this.$router.push({
   path:`/index/${id}` 
})

// 详情页获取参数
this.$route.params.id

```

这种方式参数是以/id跟在url后，**刷新页面后参数不会丢失。**

$route.push的**params传参**（**路由配置中未指定参数**）

```js
// 列表中跳转
this.$router.push({
   name:'detail',
   params:{
       id:id     
   }
})

// 详情页获取参数
this.$route.params.id
```

这种方式的传参，必须**使用name**进行跳转，未在路由配置:id，url后不会显示id，**刷新页面后参数会丢失。**

### query传参

```js
// 路由配置
{ 
    path: '/detail',
    name: 'detail', 
    component: Detail 
}

// 列表中跳转
this.$router.push({
   path:'/detail',
   query:{
       id:id
   }
})

// 详情页获取参数
this.$route.query.id
```

这种方式的参数以**?id跟在url后**，类似get传参，并且，**query必须使用path进行传参。刷新页面后参数不会丢失。**

#### params和query传参区别：

1. params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。**params一旦设置在路由，params就是路由的一部分**，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。
2. params、query不设置也可以传参，但是params不设置的时候，刷新页面或者返回参数会丢失，query并不会出现这种情况，这一点的在上面说过了

### $router和$route区别

> `$router`是VueRouter的实例对象，`$route`是当前路由对象，也就是说`$route`是`$router`的一个属性

- $router是VueRouter的一个对象，通过Vue.use(VueRouter)和Vue 构造函数得到的一个router的实例对象，这个对象是全局的对象，他包含所有的路由，包含了许多关键的对象和属性。
- $route是一个路由跳转对象，每个路由都会有一个$route对象，是一个局部的对象，可以获取对应的name,path,params,query等

## vuex刷新页面丢失数据问题

vuex是一个全局状态管理系统，通过集中式存储管理组件的状态。

vuex的数据，是存储在内存中的，浏览器F5会清除内存，重新加载js等文件，vue项目重新载入，数据就会被初始化，也就是丢失。

vue中vuex中的store数据，会在页面刷新后初始化，为了解决这一问题决定将store里面数据在页面刷新前保存到sessionStorage，至于为何用他，因为页面关闭后他会被清空，localStorage则会一直存在，cookie又太小，因此sessionStorage最合适。

1. 通过本地存储

   - 在app.vue的created方法中读取sessionStorage中的数据存储在store中，此时用vuex.store中的replaceState 方法，替换掉store的根状态
   - 在beforeunload方法中将store.state存储到sessionStorage中

   ```js
        //刷新时 根组件执行created函数 此时把缓存数据复制给vuex
        if (sessionStorage.getItem("store")) {
          this.$store.replaceState(
            Object.assign(
              {},
              this.$store.state,
              JSON.parse(sessionStorage.getItem("store"))
            )
          );
        }
   
        //在页面刷新时将vuex里的信息保存到sessionStorage里 
        window.addEventListener("beforeunload", () => {
          sessionStorage.setItem("store", JSON.stringify(this.$store.state));
        });
   ```

   replaceState:替换store的根状态，仅用状态合并或时光旅行调试

2. 通过插件vuex-perisistedstate

```js
1. 安装插件
2. 在 store/index.js 文件中添加以下代码：
import persistedState from 'vuex-persistedstate'
const store = new Vuex.Store({
 state:{},
 getters:{},
 ...
 plugins: [persistedState()] //添加插件
})
```

注意!!! vuex-persistedstate 默认使用 **localStorage** 来存储数据，若要实现无痕浏览该如何实现呢？

```js
plugins: [
    persistedState({ storage: window.sessionStorage })
]
```

`vuex-persistedstate`是没有加密的，用户的信息就暴露在缓存中, 非常的不安全，所以需要配合`secure-ls`来加密storage

```js
const ls = new SecureLS({
	encodingType: "aes", // 加密方式
	isCompression: false, // 是否启用数据压缩
	encryptionSecret: "old-beauty" // 
});
```

## **vuex**是如何实现的？

**vuex利用了vue的mixin机制，混合 beforeCreate 钩子 将store注入至vue组件实例上，并注册了 vuex store的引用属性 $store！**

在beforeCreate钩子函数中，通过vue 的mixin机制。——即每个vue组件实例化过程中，会在beforeCreate钩子前调用vuexInit方法，this指向vue实例

mixin：混入，一个混入对象、可以包含任意组件选项，当组件使用混入对象时，所有混入对象的选项将被混合进入该组件本身的选项

## keep-alive

是什么？

> 是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。

keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，避免组件反复创建和渲染，可以有效提高系统性能。

**我们用过keep-alive都知道，它不会生成真正的DOM节点，这是怎么做到的？**

Vue在初始化生命周期的时候，为组件实例建立父子关系会根据`abstract`属性决定是否忽略某个组件。在keep-alive中，设置了`abstract: true`，那Vue就会跳过该组件实例。

最后构建的组件树中就不会包含keep-alive组件，那么由组件树渲染成的DOM树自然也不会有keep-alive相关的节点了。

### `keep-alive`的生命周期

- 初次进入时：
  1. `created` > `mounted` > `activated`
  2. 退出后触发 `deactivated`
- 再次进入：
  1. 只会触发 `activated`
- 事件挂载的方法等，只执行一次的放在 `mounted` 中；组件每次进去执行的方法放在 `activated` 中
  
- 常用的两个属性 include/exclude，允许组件有条件的进行缓存。
- 两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。
- keep-alive 的中还运用了 LRU(最近最少使用) 算法，选择最近最久未使用的组件予以淘汰。

LRU 的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，所以我们将命中缓存的组件 key 重新插入到 this.keys 的尾部，这样一来，this.keys 中越往头部的数据即将来被访问几率越低，所以当缓存数量达到最大值时，我们就删除将来被访问几率最低的数据，即 this.keys 中第一个缓存的组件。

```js
//在APP.vue中
<div id="app" class='wrapper'>
  <keep-alive>
  <!-- 需要缓存的视图组件 -->
    <router-view v-if="$route.meta.keepAlive">
    </router-view>
  </keep-alive>

  <!-- 不需要缓存的视图组件 -->
  <router-view v-if="!$route.meta.keepAlive">
  </router-view>
</div>
```

## vue.$nextTick

浏览器线程：和Vue的`nextTick`息息相关的是**JS引擎线程**和**事件触发线程**。

> 在下一次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新之后的DOM。

`$nextTick `当中的操作不会立即执行，而是等数据更新、DOM更新完成之后再执行，这样我们拿到的肯定就是最新的了。

Vue异步执行DOM更新。只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作上非常重要。然后，在下一个的事件循环“tick”中，Vue刷新队列并执行实际 (已去重的) 工作。

1.nextTick是Vue提供的一个全局API由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法

2.Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发 生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。

3.所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。

## 单页面应用优缺点

传统的Web网站中，进入了新的页面，会从服务器请求完整的一个整个页面，而在SPA中，当切换到新的页面，只需要**重写页面发生了变化的部分**。

### 优点：

1. 前后端分离的优点spa都有：分工明确、接口明确、提高开发效率；
2. 页面之间切换快；
3. 减少了后端服务器的压力；
4. 后端程序只需提供API，完全不用管客户端是web还是手机。

### 缺点：

1. 首屏打开速度慢，用户首次加载需要下载SPA框架及应用程序的代码，然后在渲染页面。
2. 不利于SEO

### **如何解决不利于SEO问题：**

#### 服务端渲染

可以使用**服务端渲染**，在普通的SPA中，一般是将框架及网站代码发送到浏览器，在浏览器中生成和操作DOM，但也可以将SPA应用打包到服务器，在服务器上渲染出HTML，发送到浏览器，这样的HTML页面还不具备交互能力，还需要与SPA框架配合。所以，合理利用SSR技术，可以解决首屏慢的问题，还可以获得更好的SEO。

SSR的优点：

1. 更快的响应时间，不用等待所有的js都下载完成，浏览器就能显示比较完整的页面了；
2. 用户体验好；
3. 更好的SEO，我们可以将SEO的关键信息在后台就渲染成HTML，保证搜索引擎的爬虫都能爬取到关键数据。

SEO的缺点：

1. 占用更多的CPU和内存资源
2. 常用的浏览器API可能无法正常使用，比如window、document、alert等；

**客户端渲染**：

**优点：**

1. 前后端分离
2. 体验更好

**缺点**：

1. 前端响应速度慢，客户端渲染，前端需要进行拼接字符串的过程，耗费时间
2. 不利于SEO，百度和谷歌的爬虫对于SPA是不认的，只会记录一个页面

## vue打包性能优化

webpack打包优化

- 优化打包速度

  - 合理配置mode参数：开发环境和生产环境；

  - 缩小文件搜索范围

  - 抽离第三方模块

    > 这样做的好处是每次更改我本地代码的文件的时候，`webpack`只需要打包我项目本身的文件代码，而不会再去编译第三方库。以后只要我们不升级第三方包的时候，那么`webpack`就不会对这些库去打包，这样可以快速的提高打包的速度。

  - 增强代码压缩

    多进程并行压缩

    - webpack-paralle-uglify-plugin
    - uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)
    - terser-webpack-plugin 开启 parallel 参数

    通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。

    ```js
    npm i -D webpack-parallel-uglify-plugin
    ```

  - 图片压缩

  - 配置缓存

- 优化打包文件体积

## vue模板编译

就是将template转为render函数的过程

1. 模板编译，将模板字符串转换成elements AST
2. 优化AST，对AST进行静态节点标记，方便后续虚拟DOM更新
3. 生成代码，将AST转换为可执行的代码

## MVVM、MVC、MVP

## 前端性能优化

- 1.内存优化
- 2.启动优化
- 3.布局加载和绘制优化
- 4.卡顿优化
- 5.网络优化

1. 路由懒加载
2. 开启CDN加速（建议选配，CDN虽然速度快，但没有本地打包稳定）
3. Gzip压缩
4. 代码压缩
5. 公共代码抽离，写在configureWebpack模块中
6. 图片压缩
7. 首屏骨架屏优化
8. nginx配置缓存
9. 按需加载



## esModule和commonJs

1. CommonJS和ES Module都对循环引入做了处理，不会进入死循环，但方式不同：

2. - CommonJS借助模块缓存，遇到require函数会先检查是否有缓存，已经有的则不会进入执行，在模块缓存中还记录着导出的变量的拷贝值；
   - ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。

3. CommonJS的export和module.export指向同一块内存，但由于最后导出的是module.export，所以不能直接给export赋值，会导致指向丢失。



引入原因：

- js文件作用域都是顶层，这会造成变量污染
- js文件多，变得不好维护
- js文件依赖问题，稍微不注意顺序引入错，代码全报错

好处：

- 解决变量污染问题，每个文件都是独立的作用域，所以不存在变量污染
- 解决代码维护问题，一个文件里代码非常清晰
- 解决文件依赖问题，一个文件里可以清楚的看到依赖了那些其它文件

### commonJs

1. 导出：`CommonJs`中使用`module.exports`导出变量及函数，也可以导出任意类型的值
2. 导入：`CommonJs`中使用`require`语法可以导入，如果想要单个的值，可以通过解构对象来获取。

### esModule

1. 导出：在`Es Module`中导出分为两种，单个导出(`export`)、默认导出(`export default`)
2. 导入：`Es Module`使用的是`import`语法进行导入。如果要单个导入则必须使用花括号`{}` ，**注意：这里的花括号跟解构不一样**。

## npm run XXX发生了什么

- 运行 npm run xxx的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；

  .bin 目录，这个目录不是任何一个 npm 包。目录下的文件，表示这是一个个软链接，打开文件可以看到文件顶部写着 `#!/bin/sh` ，表示这是一个脚本。

  由此我们可以知道，当使用 `npm run serve` 执行 `vue-cli-service  serve` 时，虽然没有安装 `vue-cli-service`的全局命令，但是 npm 会到 `./node_modules/.bin` 中找到 `vue-cli-service` 文件作为  脚本来执行，则相当于执行了 `./node_modules/.bin/vue-cli-service serve`（最后的 serve 作为参数传入）。

- 没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx就是安装到到全局目录；

- 如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。

**npm install**的过程大致就是从package.json中读取所有的依赖信息，然后再与node_modules中已经安装的依赖进行对比，如果没有则通过package-lock.json获取相应版本号下载安装。如果已经存在则会通过package-lock.json检查更新。

## package.json和package-lock.json

1. **`package.json 用来描述项目及项目所依赖的模块信息。`**

   `~` 会匹配最近的小版本依赖包；`^` 会匹配最新的大版本依赖包；`*` 安装最新版本的依赖包。

2. **package-lock.json**就是来对整个依赖树进行版本固定的。它准确的描述了当前项目npm包的依赖树，并且在随后的安装中会根据 package-lock.json 来安装，保证是相同的一个依赖。为了让不同人电脑安装的所有依赖版本都是一致的，确保项目代码在安装所执行的运行结果都一样。

   `npm install`时候，会自动生成一个`package-lock.json`文件，和`package.json`在同一级目录下。`package-lock.json`记录了项目的一些信息和所依赖的模块。这样在每次安装都会出现相同的结果。

   当我们下次再`npm install`时候，npm 发现如果项目中有 `package-lock.json` 文件，会根据 `package-lock.json` 里的内容来处理和安装依赖而不再根据 `package.json`。


# 计网

## http的请求方法

http/1.1

get：获取资源

post：提交数据，上传数据，通常会造成服务器资源的修改

put：上传文件，更新数据

HEAD：获取资源的**元信息**

DELETE：删除资源

CONNECT：建立连接隧道，用于**代理服务器**，使用隧道进行TCP通信

OPTIONS：列出可对资源实行的请求方法，用来**跨域**请求

TRACK ：追踪请求-响应的传输路径

### get和post

1. **幂等性:**

   get是一个幂等请求，一般get请求用于对服务器资源不会产生影响的场景，比如说请求网页的资源。Post不是一个幂等请求，一般会对服务器的资源产生影响。（幂等表示执行相同的操作，结果也是相同的）

2. **缓存：**

   get会被浏览器主动缓存，留下历史记录，post不会。

3. **参数：**

   get请求会将请求参数带在URL中，向服务器发送；post放在请求体中，适合敏感度比较高的信息

4. **编码：**

   get只能进行URL编码，只能接收ASCLL字符，POST没有限制

5. **TCP数据包：**

   get请求把请求报文一次性发出去，而post会分为两个TCP数据包，首先发送header部分，服务器响应100 continue,然后再发body部分（火狐除外，POST只发一个TCP包）

6. **请求长度：**

   浏览器及服务器对URL长度的限制，会影响get请求发送数据时的长度。这个限制是浏览器规定的，并不是RFC规定的。

### 状态码

- 1XX：接收的请求正在处理
- 2XX：请求正常处理完毕
- 3XX：重定向状态，资源位置发生变动，需要重新请求。
- 4XX：客户端错误状态码，服务器无法处理请求
- 5XX：服务器错误状态码，服务器处理请求出错

**常用状态码：**

- 100 CONTINUE：继续，客户端应继续其请求

- 101：切换请求协议，从http切换至websocket

- 200 OK：请求成功，有响应体

- 201 created：已成功请求并创建了新的资源

- 204  No Content：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分

- 206 Partical Content :表示客户端进行了范围请求，而服务器成功的执行了这部分的get请求，响应报文中包含Content-Range范围内容

- 301Moved Permanently：**永久性重定向**。请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 

- 302 Found：**临时性重定向**：该状态码表示请求的资源已经分配了新的url，希望本次能够以新的uri进行访问，通过 302 响应码和 **Location** 头部，告诉客户端该资源已经迁移⾄新的URI

  了，于是客户端需要再发送 url2 请求以获得服务器的资源

- 303 See Other：该状态码表示由于请求对应得资源存在着另一个uri，应该使用get方法定向获取请求资源

- 304 Not Modified：该状态码表示客户端发送附带条件得请求时，服务器端允许请求去访问资源，但因请求未满足条件的情况后，直接返回304。304状态码返回时，不包含任何相应得主体部分

- 307Temporary Redirect ：临时重定向。,遵守浏览器标准， 不会将post请求改为get请求

- 400 BadRequest：请求报文中存在语法错误。当错误发生时，需修改请求得内容后再次发送请求，浏览器会像200OK一样对待该状态码

- 401 Unauthorized：表示发送的请求需要有通过http认证得认证信息。响应中必须包含一个适用于被请求资源得WWW-Authenticate首部用于质询用户信息

- 403Forbidden：表示对请求资源得访问被服务器拒绝了。如果想对拒绝原因给出详细理由在实体的主体部分对原因进行描述

- 404 Not Found：表示服务器无法再找到请求得资源，也可以在服务器端拒绝请求且不想说明理由时使用

- 500Internal Server Error：表示服务器在执行请求时发生了错误，也可能时web应用存在得bug或某些临时得故障

- 503 Service Unavailable：表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## http和https

**http：**

超文本传输、信息是明文传输，支持客户端/服务器模式、简单快速、灵活、无连接、无状态

无连接：**限制每次连接只处理一个请求**。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

无状态：**每次请求都是独立的。**对事物处理没有记忆能力，服务器根据请求返回发送数据，但是发送完不会记录任何信息。优点在于解放了服务器，不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。

可以通过cookie和session解决无状态的问题。

**HTTPS**

在HTTPS中，使用**安全套接字层**（SSL）和**传输层安全性**（TLS）对通信协议进行加密。

HTTPS主要做了**数字加密**（防止信息被窃取）、**身份认证**（冒充分险，确认对方真实身份，防止中间人攻击并建立用户信任）、**数据一致性**（防止数据信息被篡改，用户发的是什么，服务器就收到什么）

通过**混合加密**（对称加密和非对称加密）的方式实现信息的机密性，解决了窃听分险；**摘要算法**实现完整性，为数据生成独一无二的指纹，指纹用于效验数据的完整性，解决了篡改的风险；将服务器公钥放到**数字证书**中，解决了冒充的分险。

**请求过程：**

![image-20220315152438480](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315152438480.png)

1. 客户端向服务器发送请求报文：客户端支持的SSL/TLS协议版本；客户端生成的随机数；客户端支持的密码套件列表（如RSA加密算法）；
2. 服务器向客户端发出响应：确认SSL/TLS协议版本，如果浏览器不支持，关闭加密通信；服务器产生随机数；确认密码套件列表；服务端的数字证书；
3. 客户端收到服务端回应后，先确认**服务器数字证书的真实**性，如果没有问题取出服务器的公钥，使用它加密报文，向服务器发送：一个随机数，会被服务器公钥加密；会话秘钥：之前过程生成的三个随机数用双方协商的加密算法，各自生成本次通信的会话秘钥；客户端握手结束通知，表示客户端的握手阶段已经结束，同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验。
4. 服务器最后的响应：服务器收到客户端发送的第三个随机数后，通过协商的加密算法，生成本次通信的会话秘钥，向客户端发送最后的信息：加密通信算法改变通知，表示之后的信息都将用会话秘钥加密通信；服务器握手结束通知表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供客户端校验。

https作用：

- 建立安全信息通道，保证数据的安全性
- 确认网站的真实性

https缺点：

- 由于存在复杂的验证阶段，https协议的握手时间会比较费时
- https加密范围有限
- https链接缓存不如http高效，会增加数据开销

对称加密与非对称加密最主要的区别就是对称加密使用相同的密匙进行解密，而非对称加密像是发送了一个锁，接收方将自己的钥匙挂在锁上传回来，加密方再使用自己的钥匙开锁获得对方的密匙

## http，http/1.1，http/2

**HTTP/1.1 VS HTTP/1.0 ：**

1. 使⽤ TCP **⻓连接**的⽅式改善了 HTTP/1.0 短连接造成的性能开销。
2. ⽀持**管道（pipeline）⽹络传输**，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

 **HTTP/1.1 缺点：**

1. 请求 / 响应头部（Header）**未经压缩**就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；
2. **队头阻塞**：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据；
3. 没有请求优先级控制；
4. 请求只能从客户端开始，服务器只能被动响应

**HTTP/2 VS HTTP/1.1**

1. 头部压缩：如果同时发送多个请求，他们的头是一样的，会消除重复的部分。
2. 二进制格式：头信息和数据体都是二进制，统称为帧：头信息帧和数据帧。对计算机友好，无需将明文报文转成二进制，而是直接解析二进制报文，增加了数据的传输效率；
3. 数据流：每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以**指定数据流的优先级**。优先级⾼的请求，服务器就先响应该请求。
4. 多路复用：**一个连接中并发多个请求或回应，不用按照顺序一一对应**。解决了**队头阻塞**的问题，降低了延迟，大幅度提高了连接的利用率。
5. 服务器推送：服务不是被动的响应，可以主动向客户端发送消息。

HTTP/2缺点：

HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的᯿传机制，这样在⼀个 TCP 连接中的**所有的** **HTTP** **请求都必须等待**这个丢了的包被重传回来。

>面试官: http2实现了多路复用,http1.x为什么不能多路复用?
>我: 我说因为http1.x要按照顺序来.
>面试官: 没错,但是为什么http1.x要按照顺序来?
>我: 唔...这个不知道..
>面试官: HTTP/1.1是基于文本分割解析的协议,也没有**序号**,如果多路复用会导致顺序错乱,http2则用帧的方式,等于切成一块块,每一块都有对应的序号,所以可以实现多路复用.

## HTTP1.1如何解决HTTP中的队头阻塞问题

HTTP 传输是基于`请求-应答`的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的`HTTP队头阻塞`问题。

### 并发连接

一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。（在RFC2616规定过客户端最多并发 2 个连接，Chrome中是6个）

但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

### 域名分片

一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。

比如 content1.sanyuan.com 、content2.sanyuan.com。

这样一个`sanyuan.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

## http/1.1如何优化

![image-20211229223548922](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229223548922.png)

- 尽量避免发送 *HTTP* 请求；

- 减少HTTP请求次数：
  - 减少重定向请求次数，**重定向的⼯作交由代理服务器完成，就能减少** **HTTP** **请求次数了**
  - 合并请求：
  - 延迟发送请求：以通过「**按需获取**」的⽅式，来减少第⼀时间的 HTTP 请求次数

- 减少服务器的 *HTTP* 响应的数据大小：有损压缩和无损压缩

  - 无损压缩：指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合⽤在⽂本⽂件、程序可执⾏⽂件、程序源代码。**gzip为无损压缩**

  - 有损压缩主要将次要的数据舍弃，牺牲⼀些质量来减少数据量、提⾼压缩⽐，这种⽅法经常⽤于**压缩多媒体数据**，比如**⾳频、视频、图⽚**。


![image-20211229232825107](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229232825107.png)

## TCP和UDP区别

TCP：传输控制协议

UDP：面向数据报协议



TCP是一个**面向连接的**、**可靠的**、**基于字节流**的**传输层**协议

- **连接**：TCP是面向连接的传输层协议，传输数据前要先建立连接；UDP不需要连接，即刻传输数据
- **服务对象：**TCP是一对一的两点服务，UDP支持一对一，一对多，多对多的交互通信
- **可靠性：**TCP是可靠交付数据的，表现在**有状态，可控制**。TCP会精准记录哪些数据发送了 ，哪些数据被接收了，哪些没有接收到，而且保证数据包按序到达，不允许差错，这是**有状态**。当意识到丢包或者网络环境不佳，TCP会根据具体情况调整自己的行为，控制自己发送速度或者重发。这是**可控制**。UDP不可靠性、不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。
- **传输方式：**TCP是流式传输，基于字节流，没有边界，保证顺序和可靠；UDP数据传输基于数据报的
- **头部开销：**TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的。UDP ⾸部只有 8 个字节，并且是固定不变的，开销较小。

### 为什么需要tcp

IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。

### TCP和UDP应用场景：

TCP：面向连接，保证数据的可靠性交付，常用于：FTP文件传输，HTTP/HTTPS

UDP：包总量较少的通信，DNS、SNMP等；视频、音频等多媒体通信；广播通信

## 三次握手和四次挥手

### 三次握手

![image-20211106130349888](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211106130349888.png)

![image-20211216143947699](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211216143947699.png)

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211216144019918.png" alt="image-20211216144019918" style="zoom:150%;" />

![image-20211216144045754](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211216144045754.png)

### 四次挥手

![image-20211229235403614](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229235403614.png)

- 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客

  户端进⼊ FIN_WAIT_1 状态。

- 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。

- 客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。

- 等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。

- 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态

- 服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。

  客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。

#### 为什么需要四次？

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

- 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。

#### 为什么TIME_WAIT等待时间是2MSL？

MSL 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。原因：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以**⼀来⼀回需要等待** **2** **倍的时间**。经过 2MSL 这个时间，**⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。**

#### 为什么要TIME_WAIT等待？

- 防止旧连接的数据包
- 保证连接正确关闭，TIME-WAIT 作⽤是**等待⾜够的时间以确保最后的** **ACK** **能让被动关闭⽅接收，从⽽帮助其正常关闭。**客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK 状态。当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程就会被终⽌。

## TCP如何保证可靠？

TCP 是通过序列号、确认应答、重发控制、连接管理以及窗⼝控制等机制实现可靠性传输的。

![image-20211230153115759](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211230153115759.png)

**1、重传机制**：

- **超时重传**：在发送数据时，设置一个定时器，就是一个超时重传时间（RTO，略大于RTT，RTT，一个往返时延），当超过定时器的时间，没有收到对方的ACK确认应答报文，就会重发该数据。

  **引发原因**：数据包丢失、确认应答丢失；

- **快速重传**：**不以时间为驱动，而是以数据驱动重传**。当一个数据报由于某些原因没有发送给server，其余数据包发送，返回相同的确认号，当发送方收到了三个确认时，就知道那个数据报没有发送，就会在定时器过期之前，重传丢失的数据包（重传从丢失的数据包开始之后所有的数据包）。

**2、滑动窗口：**

​	窗口的实现实际上是操作系统开辟的⼀个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲	区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

**3、流量控制：**

​		**TCP提供一种机制可以让「发送⽅」根据「接收⽅」的实际接收能力控制发送的数据量，这就是所谓		的流量控制。**避免「发送方」的数据填满「接收方」的缓存，但是并不知道⽹络的中发⽣了什么。

**4、拥塞控制：**

在网络拥堵时，如果继续发送大量数据包，可能导致数据包时延，丢失等，TCP重传会导致网络的负担更重，导致更大的延迟和更多的丢包，所以控制就是**避免「发送方」的数据填满整个网络。**

拥塞控制的四个算法：

- **慢启动**：一点一点提高发送数据包的数量。**当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd的⼤⼩就会加1**。慢启动开始呈**指数型**增长，当**cwnd<慢启动门限**（ssthresh）时，使用慢启动算法，当**cwnd >= ssthresh**时，使用拥塞避免算法。

- **拥塞避免**

  每当收到⼀个ACK 时，cwnd增加1/cwnd。呈**线性增长**

- **拥塞发生算法**

  一直增长，网络进入拥塞状况，会出现丢包现象，就会进行重传，进入了拥塞发送算法。此时**cwnd=1**，**慢启动门限（ssthresh）= cwnd/2**；

- **快恢复**

  快重传和快恢复一般同步使用，快恢复认为，还能收到3个重复的ACK说明网络不是很糟糕，没有必要超时重传，在快恢复之前，慢启动门限为原来接收窗口的一半。

  进入快恢复时，

  1. cwnd = 慢启动门限+3个数据包，
  2. 重传丢失的数据包；
  3. 如果再收到重复的 ACK，那么 cwnd 增加 1；
  4. 如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从丢包时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊拥塞避免状态；

## 滑动窗口---------未完成

## 在浏览器输入URL，按下回车

`解析URL -> DNS解析获取ip地址（判断是否有缓存）-> TCP三次握手 -> HTTPS 请求 -> 返回数据 -> 页面渲染 -> TCP四次挥手`

### **1、对URL进行解析**

​	URL只能是字母和数字，还有特殊符号，如果存在非法字符，则对非法字符进行**转义**后再进行下一过程。URL的编码规则是**utf-8**，怎么保证都是utf-8编码？可以用**encodeURIComponent**

encodeURIComponent和encodeURI区别：

encodeURIComponent编码范围更广，适合给参数编码，encodeURI适合给URL本身编码

### 2、DNS域名解析

#### DNS缓存

- 询问浏览器 `DNS` 缓存
- 询问操作系统中的缓存
- 询问本地操作系统 `DNS` 缓存（即查找本地 `host` 文件）
- 询问 `ISP`（`Internet Service Provider`）互联网服务提供商（例如电信、移动）的 `DNS` 服务器

输入域名，操作系统先从**hosts文件**中找是否有记录，如果有，从将IP地址返回；否则，找**本地DNS服务器**解析有没有缓存；再从**计算机上配置的DNS解析器**查找是否有缓存，**递归查找**，有就返回；否则**根DNS服务器**查找 -> 顶级服务器查找 ->  权威服务器查找 **迭代查找**（.com域名是哪个服务器管理 -> baidu.com -> www.baidu.com），最后获取IP地址

#### HTTP请求缓存（强缓存和商缓存）

![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0f5e26bfdb749e6a9e339dfac224fe1~tplv-k3u1fbpfcp-watermark.awebp)

**建立完链接就要请求HTML文件**了，如果html文件在缓存里面浏览器直接返回，如果没有，就去后台拿

浏览器缓存：强制缓存和协商缓存

- 当浏览器首次加载资源成功后，服务器会返回200，把文件下载下来，并将response中header一并缓存（里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差）
- 当再次请求资源时，首先经过强缓存的处理，cache-control优先级最高，cache-control中有max-age，将上次返回200时的date和当前时间作差，如果没有超过max-age，命中强缓存；否则走协商缓存
- 协商缓存时，会向服务器发送header带If-None-Match和If-Modified-Size的请求，服务器会比较Etag，一致命中协商缓存，返回304；不一致，带上新的文件和Etag，并返回200；
- 如果服务器收到的请求无Etag，将If-Modified-size和请求文件最后一次修改时间比较，一致命中协商缓存，返回304；不一致返回新的Last-Modified和文件，并返回200。

#### 缓存位置

##### 1.Service Worker

定义：运行在浏览器背后的独立线程，一般可以用来实现缓存功能
触发：HTTPS + 写功能代码
存储内容：任何文件

优点：缓存是持续性，自由控制缓存方式、匹配缓存规则等
缺点：没命中缓存时，会依次走下一级的缓存，最后无则发起请求，
     不管是从 Memory Cache 或 Fetch请求获取，
     都将显示为从 Service Worker 中获取的内容

##### 2.Memory Cache

定义：内存中的缓存
触发：当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存
存储内容：当前页面中的`体积小`的资源文件，如css、js、图片

优点：读取速度快
缺点：缓存时间短。关闭网页，Memory Cache释放
实践：``<link rel="prefetch">``下载的资源放入内存缓存
注意：内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，
同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。
如果当前系统内存使用率高的话，文件优先存储进硬盘

##### 3.Disk Cache

定义：存储在硬盘中的缓存
触发：根据浏览器请求头判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求
存储内容：大文件

优点：容量大，存储时间长
缺点：读取速度慢
注意：即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据

##### 4.Push Cache

定义：推送缓存，HTTP/2的策略
触发：当以上三种缓存都没命中时，它才会使用
存储内容：可以推送 no-cache 和 no-store 的资源

缺点：1. 只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂
     在Chrome浏览器中只有五分钟左右

     2. Push Cache 中的缓存只能被使用一次

### 3、TCP三次握手

- 客户端发送SYN=1的TCP数据包给服务器，并携带一个随机数seq(序号字段)
- 服务器收到客户端请求后，向客户端发送一个确认号ack= seq+1，和随机数seq ,SYN=1,ACK(位码)=1
- 客户端收到后看序列号是否正确，正确的话，发送ACK=1，ack= seq+1，服务器收到后确认ack=1和seq加一则连接成功。

优点：

- 三次握手可以同步双方初始序列号
- 避免资源浪费

#### **为什么两次握手不行？**

- 服务器多次建立连接，避免资源浪费

  发生拥塞时，再次发送请求，服务器一直保持连接，服务器压力大

- 避免历史连接的建立，如果是两次就不能判断是否为历史连接、

- 初始化序列号

#### **网卡把数据包传输出去到服务器发生了什么?**

### 4、发送请求

### 5、返回HTML后布局和渲染

返回HTML后，解析HTML；

构建DOM树：从上到下解析HTML文档生成DOM节点树，

构建CSSOM树：加载解析样式生成CSSOM树

执行JavaScript:加载并执行JavaScript代码

构建渲染树：根据DOM树和CSSOM树,生成渲染树（render Tree）

布局（layout）：根据渲染树将节点的每个节点布局在屏幕上的正确位置

绘制（painting）：遍历渲染树绘制所有节点，为每个节点适用对应的样式

浏览器工作流程：构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制。

渲染阶段：生成图层树、生成绘制列表、生成图块、优先选择视口附近的图块生成位图数据、展示内容



- 浏览器通过http协议请求到服务器，获取到html样式后，自上而下进行解析，**构建dom树，document.readystate = "loading"**——正在加载
- 遇到link外部css，创建线程记载，并继续解析文档
- 遇到外部js，并且没有设置async或defer，浏览器阻塞并加载，等待js加载完成并执行该脚本，然后继续解析文档，对于设置async，defer的浏览器创建线程加载，并继续解析文档，async脚本加载完后立即执行
- 遇到img，先正常解析dom架构，然后 浏览器异步加载src，并继续解析文档
- **文档解析完成后，document.readystate =“interactive”**——可交互，并触发domcontentloaded事件，所有设置defer的脚本还会按顺序执行，dom树和cssom树进行关联形成渲染树——rendertree，并绘制在页面上
- **所有defer的脚本加载完成并执行后，img等加载完成，document.readystate ="complete"**——完成,window对象触发事件。

### 6、连接结束（四次挥手）

![image-20211229235403614](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211229235403614.png)

- 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客

  户端进⼊ FIN_WAIT_1 状态。

- 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。

- 客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。

- 等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。

- 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态

- 服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。

  客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。

## 跨域

**同源策略**：**协议，域名，端口号**一致

非同源站点限制：

1. 限制XMLHttpRequest请求；
2. 不能读取和修改对方的DOM；

当浏览器向目标URI发Ajax请求时，只要当前URL和目标URL不同源，就产生跨域。

跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。

**渲染引擎**和**V8引擎**都在渲染进程中。

**浏览器进程：**

- 浏览器主进程
- GPU进程
- 插件进程
- 网络进程
- 渲染进程
  - GUI渲染进程
  - js引擎
  - 事件触发
  - 定时器触发
  - 异步http请求

当xhr.send被调用，Ajax请求准备发送请求的时候，其实还是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个**渲染进程**装进了**沙箱**，并且为了防止CPU芯片一直存在的Spectre和Meltdown（攻击指令序列）漏洞【Meltdown与Spectre利用这种侧信道可以进行越权内存访问，甚至读取整个内核的内存数据】，采取了站点隔离的手段，给每一个不同的站点分配了沙箱，互不干扰。

沙箱中的渲染进程没有办法发送网络请求，只能通过**网络进程**来发送。涉及到了进程间的通信，利用Unix Domain Socket套接字，配合事件驱动的高性能网络并发库libevent完成进程的IPC过程。

请求传递给了浏览器主进程，主进程接收到后，才会真正的发出网络请求。在服务器端处理完数据后，将响应返回，主进程检查到跨域，并且没有CORS响应头，就会将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。

### CORS

服务端设置**Access-Control-Allow-Origin** 就可以开启 CORS。盖属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

#### **简单请求：**

- 条件一：请求方法为 GET、POST 或者 HEAD

- 条件二：请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)

请求过程：

发送请求前，会在请求头中添加Origin字段，用来说明请求来自哪个源。服务器拿到请求后，在回应时对应的添加**Access-Control-Allow-Origin**字段，如果Origin不在这个字段范围中，那么浏览器就会将响应拦截。

#### **非简单请求：**

复杂请求得cors会在正式通信前，增加一次http请求，成为预检请求，该请求是option方法得，**通过该请求来指导服务端是否允许跨域请求**。

- 使用put或delete
- 发送json格式的数据
- 请求中带有自定义头部

##### 为什么要预检请求：

复杂请求可能对服务器数据产生副作用，所以在请求之前需要先请求服务器，当前网页所在域名是否在服务器的许可名单中，服务器允许后，浏览器才会发出正式请求，否则不发送。



在预检请求的响应返回后，如果请求不满足响应头的条件，则触发`XMLHttpRequest`的`onerror`方法，当然后面真正的**CORS请求**也不会发出去了。**CORS 请求的响应**。现在它和**简单请求**的情况是一样的。浏览器自动加上`Origin`字段，服务端响应头返回**Access-Control-Allow-Origin**

**响应字段**也分为两部分。一部分是对**预检请求**的响应，一部分是对**CORS请求**的响应。

**预检请求的响应**

```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: * //表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。
Access-Control-Allow-Methods: GET, POST, PUT  //表示允许的请求方法列表。
Access-Control-Allow-Headers: X-Custom-Header  //表示允许发送的请求头字段
Access-Control-Allow-Credentials: true //这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为true, 并且在前端也需要设置withCredentials属性,xhr.withCredentials = true;
Access-Control-Max-Age: 1728000  //预检请求的有效期，在此期间，不用发出另外一条预检请求。
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
```

**CORS设置响应头**

后台那边：

```js
app.all('/cors-server',(request,response) => {
    //设置响应头
    response.setHeader("Access-Control-Allow-Origin",'*');
    response.setHeader("Access-Control-Allow-Headers",'*');
    response.setHeader("Access-Control-Allow-Method",'*');
    response.send('hello CORS');
})
```

### JSONP

**原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制。因为所有的src属性和href属性都不受同源策略限制。可以请求第三方服务器数据内容。**

虽然XMLHttpRequest对象遵循同源政策，但是script标签可以通过**src**填上目标地址从而发出**GET**请求，实现跨域请求并拿到响应。

前端调用：

```js
jsonp({
  url: 'http://localhost:3000',
  params: { 
    a: 1,
    b: 2
  }
}).then(data => {
  // 拿到数据进行处理
  console.log(data); // 数据包
})
```

和`CORS`相比，JSONP 最大的优势在于**兼容性**好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。

**jsonp与ajax相比**：
都是客户端向服务端发送请求，从服务端获取数据的方式，但ajax属于同源策略，jsonp属于非同源策略

优缺点：
简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题，缺点是仅支持get方法具有局限性，不安全可能会受到**xss攻击**，难以确定jsonp请求是否失败，可以通过使用定时器指定响应的允许时间，超出时间认为相应失败。错误处理，jsonp在调用失败的时候不会返回各种HTTP状态码。只有200，没有404，没有500等状态码让你来标识是否要重新调用。

### websocket

h5提供的一种浏览器与服务器进行**全双工通信**的网络技术，属于**应用层**协议。

1. 单向通信/单工通信：只能由一个方向的通信而没有反方向的交互
2. 双向交替通信/半双工通信：通信双发都可以发送信息，但不能双方同时发送
3. 双向同时通信/**全双工通信**：通信双发可以同时发送和接收信息

特点：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

一些api：

- webSocket.onopen：连接成功后的回调函数

- webSocket.onclose：用于指定连接关闭后的回调函数

- webSocket.onmessage:用于指定收到服务器数据后的回调函数

- webSocket.send():用于想服务器发送数据

### location.hash+iframe

原理是利用location.hash来进行传值。

假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息。
1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面
2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据
3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值

注意：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe

### Nginx

反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的**负载均衡**，换句话说，反向代理帮**其它的服务器**拿到请求，然后选择一个合适的服务器，将请求转交给它。

Nginx 是一种高性能的`反向代理`服务器，可以用来轻松解决跨域问题。

Nginx 相当于起了一个跳板机，这个跳板机的域名也是`client.com`，让客户端首先访问 `client.com/api`，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给`server.com`，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

 使用反向代理最主要的两个原因：
 1）安全及权限。可以看出，使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须首先通过Nginx。可以通过在Nginx层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。
 2）负载均衡。例如一个网站的内容被部署在若干台服务器上，可以把这些机子看成一个集群，那么Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上（内部模块提供了多种负载均衡算法），从而实现服务器压力的负载均衡。
3）nginx还带有健康检查功能（服务器心跳检查），会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态，一旦发现某台服务器异常，那么在以后代理进来的客户端请求都不会被发送到该服务器上（直到后面的健康检查发现该服务器恢复正常），从而保证客户端访问的稳定性。

### postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，允许来自不同源得脚本采用异步方式进行有限的通信，可以实现跨文档，多窗口，跨域消息传递。它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

```js
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

- otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口
- message: 将要发送到其他 window的数据。
- targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
- transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

## HTTP缓存以及代理缓存

先说一下**强缓存**和**协商缓存**：

首先通过**Cache-control**判断强缓存是否可用：

1. 如果强缓存可以，直接使用，

2. 否则是协商缓存，http发送请求，服务器通过If-Modified-Size判断，（If-Modified-Size：http请求头标签，发送http请求时，把浏览器缓存页面最后修改时间一起发送到服务器去，服务器把这个时间和服务器上文件最后修改时间进行比较。）

   - 如果时间一样，返回304，告诉浏览器从缓存中获取文件
   - 否则，返回200和最新修改的文件，客户端丢弃原来的文件，缓存新文件，并显示到浏览器中。

   **强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道**，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。

   ![image-20211123113450746](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211123113450746.png)

### http代理

http是基于`请求-响应`模型的协议，一般由客户端发请求，服务器来进行响应。

#### 功能：

1、负载均衡。

​		客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括**随机算法**、**轮询**、**一致性hash**、**LRU**`(最近最少使用)`等等

2、保障安全。

​		利用**心跳机制**监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。

3、代理缓存。

​		将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。

### 代理缓存

对于源服务器来说，它也是有缓存的，比如**Redis, Memcache**，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。

由此引入了**缓存代理**的机制。让`代理服务器`接管一部分的服务端HTTP缓存，客户端缓存过期后**就近**到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。

缓存代理的控制分为两部分，一部分是**源服务器端**的控制，一部分是**客户端**的控制



## cookie、session、token

**cookie:**

1. 客户端发送 HTTP 请求到服务器
2. 当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段
3. 浏览器收到响应后保存下 Cookie
4. 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。

`Expires` 用于设置 Cookie 的过期时间；

`Secure`：只能通过HTTPS传输cookie；

`HttpOnly`：通过js脚本将无法读取到cookie信息，预防XSS攻击的重要手段。（只能降低受损范围）

`SameSite`：让Cookie在跨站请求时不会被发送，从而阻止跨站请求伪造（CSRF）攻击。

三个属性值：

1. **Strict** 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。
2. **Lax** 允许部分第三方请求携带 Cookie
3. **None** 无论是否跨站都会发送 Cookie

**token:**

客户端发送带有用户名密码的post请求，服务端验证通过生成token，以token作为key，将用户信息映射关系存入Redis，服务器将token存入cookie中，客户端发送带有token cookie的请求，服务器以token为key向redis获取用户信息，服务器返回响应信息。

jwt:

服务端生成token返给前端，前端将token携带在请求头中。如果有多个服务端，怎么验证？后端在生成token是会有一个**签名**，服务端会根据签名验证，验证通过，才会吧数据返回给前端。

**为什么用token不用cookie和session？**

首先token比cookie和session更加**安全**，**每个请求都有标签并且可以防止监听**，**服务端是无状态**的，可以减小服务端的压力并且token**支持跨域**。所以在现在小程序，APP都使用token来鉴权。而cookie存在在客户端就可以截取到的问题，不安全，session如果访问量过大，服务器存储的session会很多，需要定时清理session，并且如果网站是集群部署的话，有共享session的问题，每个服务器都会共享session，存在扩展性不好的问题。

session和cookie的引入是因为http是一种无连接、无状态的协议，使用它们来实现状态的记录。



### Cookie 和 Session 的区别

- **安全性：** Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同：** Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同：** 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

### Token 和 Session 的区别

- Session 是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。而 Token 是**令牌**，**访问资源接口（API）时所需要的资源凭证**。Token **使服务端无状态化，不会存储会话信息。**
- Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。**
- 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。**

### JWT优点

- 用户的状态不会存储在服务端的内存中，这是一种 **无状态的认证机制**

- 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。

- 由于 JWT 是自包含的，因此减少了需要查询数据库的需要

- JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。

- 因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而**不需要担心跨域资源共享问题**（CORS）

### 使用 cookie 时需要考虑的问题

- 因为存储在客户端，容易被客户端篡改，使用前需要验证合法性
- 不要存储敏感数据，比如用户密码，账户余额
- 使用 httpOnly 在一定程度上提高安全性
- 尽量减少 cookie 的体积，能存储的数据量不能超过 4kb
- 设置正确的 domain 和 path，减少数据传输
- **cookie 无法跨域**
- 一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie
- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**



### 使用 session 时需要考虑的问题

- 将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session
- 当网站采用**集群部署**的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。
- 当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。
- **sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？** 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现
- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**



### 使用 token 时需要考虑的问题

- 如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。
- **token 完全由应用管理，所以它可以避开同源策略**
- **token 可以避免 CSRF 攻击(因为不需要 cookie 了)**
- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**



### 使用 JWT 时需要考虑的问题

- 因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
- JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
- JWT 不加密的情况下，不能将秘密数据写入 JWT。
- JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
- JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。
- JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
- JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。
- 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。



A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？

- 一种解决方案是 session 数据持久化，**写入数据库或别的持久层**。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。

- 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。

### localStorage和sessionStorage

sessionStorage是存储一个**会话**中的数据，数据只有在同一个会话的页面中才可以访问并且会话结束数据也会被销毁。因此sessionStorage不是一种持久化的本地存储，是会话级别的存储。localStorage是用于持久化的本地存储，除非主动删除数据，数据是不会过期的。两者都存储在客户端，不参与服务端的通信。

### Web Storage和cookie

Web storage 和 cookie相似，区别是Web Storage是为了**更大容量存储设计**的。Cookie的大小是受限的，并且每次请求一个新页面时，cookie都会被发送过去，这样无形中浪费了带宽，并且cookie不可以跨域调用。**token 完全由应用管理，所以它可以避开同源策略**。

Web Storage拥有setItem，getItem，removeItem，clear等方法，而cookie需要前端开发者自己封装setCookie，getCookie。

Web Storage是为了在本地存储数据，而cookie是为了与服务器进行交互，作为http规范的一部分存在。



## http和https

**http**（超文本传输协议）用于浏览器与服务器间传递信息，http协议**无状态**（不保存状态）且使用**明文传输**，不对信息进行加密。进而发展出了**https**（安全超文本传输协议），其在http的基础上加入了SSL安全套接层/TLS通信加密协议。   //http使用80端口，https使用443端口

客户端使用https与服务器通信的步骤（非对称加密）

（1） 客户端使用https的url访问服务器并要求建立SSL连接

（2） Web服务器收到客户端请求后将网站的证书信息（包含公钥）传给客户端

（3） 客户端浏览器与服务器协商加密等级

（4） 客户端浏览器根据加密等级建立会话密匙，而后用公钥加密密匙传输给服务器

（5） 服务器使用自身私钥解密出会话密钥

（6） 客户端与服务器开始通信

## 前端图片知识

### **input的file类型：**

input的file类型会渲染为一个按钮和一段文字。点击按钮可打开文件选择窗口，文字表示对文件的描述（大部分情况下为文件名）；file类型的input会有files属性，保存着文件的相关信息。

```js
document.querySelector('#file').addEventListener('change',(fileChoosed) => {
    console.log('fileChoosed', fileChoosed.target.files)    
})
```

文件信息是一个JSON对象，由传入的file对象组成。

- **lastModified：**数值，表示最近一次修改时间的毫秒数；

- **lastModifiedDate：**对象，表示最近一次修改时间的Date对象；

- **name：**本地文件系统中的文件名；

- **size：**文件的字节大小；

- **type：**字符串，文件的MIME类型；
- **webkitRelativePath**：此处为空；当在input上加上webkitdirectory属性时，用户可选择文件夹，此时webkitRelativePath表示文件夹中文件的相对路径。

### **FileReader**()

读取文件方法：**FileReader**()是一种**异步**文件读取机制

**FileReader方法：**

- **readAsDataURL(file)**

  读取文件内容，结果用data:url的字符串形式表示，readAsDataURL会将文件内容进行base64编码后输出

- **readAsText(file,encoding)**

  readAsText可按指定编码方式读取文件，但读取文件的单位是字符，故对于文本文件，只要按规定的编码方式读取即可；而对于媒体文件（图片、音频、视频），其内部组成并不是按字符排列，故采用readAsText读取，会产生乱码。

- **readAsArrayBuffer(file)**

  按字节读取文件内容，结果用ArrayBuffer对象表示

- **readAsBinaryString(file)**

  按字节读取文件内容，结果为文件的二进制串

- **abort()**

  终止文件读取操作

**FileReader事件：**

- onloadstart 当读取操作开始时调用
- onprogress 在读取数据过程中周期性调用
- onabort 当读取操作被中止时调用
- onerror 当读取操作发生错误时调用
- onload 当读取操作成功完成时调用
- onloadend 当读取操作完成时调用，无论成功，失败或取消

注释：

- 每过50ms左右，就会触发一次progress事件，对于较大的文件可以利用progress实现进度条；
- 由于种种原因无法读取文件时，会触发error事件。触发error事件时，相关信息保存在FileReader对象的error属性中，这个属性将保存一个对象，此对象只有一个属性code，即错误码。1表示未找到文件，2表示安全性错误，3表示读取中断，4表示文件不可读，5表示编码错误。

图片存储：

图片在后端的存储有两种方式，我们回顾一下：其一：可以将图片以独立文件的形式存储在服务器的指定文件夹中，再将路径存入数据库字段中；其二：将图片转换成二进制流，直接存储到数据库的 Image 类型字段中；

## **前端安全**

### xss —— 跨站脚本攻击

xss是一种**代码注入攻击**。攻击者在目标网站上注入恶意代码，当被攻击者登录网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。

**反射型xss**

反射型 XSS 漏洞常见于通过 `URL` 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 `URL` 才能生效，攻击者往往会结合多种手段诱导用户点击。

1. 攻击者构造出特殊的 `URL`，其中包含恶意代码。
2. 用户打开带有恶意代码的 `URL` 时，网站服务端将恶意代码从 `URL` 中取出，拼接在 HTML 中返回给浏览器。
3. 浏览器接收到响应后解释执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调节目标网站接口执行攻击者指定的操作。

```
Chrome` 和 `Safari` 能够检测到 `url` 上的xss攻击，将网页拦截掉，但是其它浏览器不行，如`Firefox
```

防范：对字符串进行编码

​			对URL查询参数进行转义后再输出到页面。

**DOM型xss**

触发xss靠的是浏览器端的dom解析。实际上就是前端js代码不够严谨，将不可信内容插入页面。取出和执行恶意代码由浏览器端完成，尽量使用.innerText`、`.textContent`、`.setAttribute()，属于前端自身的安全漏洞。

1. 攻击者构造出特殊数据，其中包含恶意代码。
2. 用户浏览器执行了恶意代码。
3. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防范：

防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。

​	1.对于`url`链接(例如图片的`src`属性)，那么直接使用 `encodeURIComponent` 来转义。

​	2.非`url`，我们可以这样进行编码：

**存储型xss**

恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。

步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

防范：

1. 前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)
2. 服务器接收到数据，在存储到数据库之前，进行转义/过滤
3. 前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤

### csrf —— 跨站请求伪造

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

![image-20211230215021073](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211230215021073.png)

**特点：**

1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。

2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)

3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等

**防御：**

1. 添加验证码（体验感差）

   强制用户与应用进行交互，完成最终请求。验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。

2. 使用token（主流）

   CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF**攻击者无法获取到的Token**。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。

   - 服务端给用户生成一个token，加密后传递给用户
   - 用户在提交请求时，需要携带这个token
   - 服务端验证token是否正确

3. Samesite Cookie属性

   Google起草了一份草案来改进HTTP协议，为**Set-Cookie响应头**新增**Samesite**属性，它用来标明这个 Cookie是个“**同站 Cookie**”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。

   - `Samesite=Strict` 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。
   - `Samesite=Lax` 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 `Get` / `OPTIONS` 、`HEAD` 请求. 但是不安全 HTTP 方法，如： `POST`, `PUT`, `DELETE` 请求时，不能作为第三方链接的 Cookie




# webpack

![image-20211206123643499](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211206123643499.png)

版本可能会有**冲突**，所以下载下面的版本号

![image-20211206124505314](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211206124505314.png)

webpack热替换：

![image-20211206130403893](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211206130403893.png)

![image-20211206132818225](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211206132818225.png)

模块化规范：有AMD/CMD（浏览器），commonjs（服务端）

浏览器对 ES Module 标准的原生支持，改变了这种情况。目前大多数浏览器已经支持通过 `<script type="module">` 的方式和 import 的方式加载标准的 ES 模块

**模块只会执行一次并且默认为defer也支持async**

## 作用：

- **模块打包**：可以将不同模块的文件打包整合在一起，并且保证他们之间的引用正确，执行有序
- **编译兼容**：通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less, .vue, .jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。
- **能力扩展**：通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。

## webpack配置项

entry——入口

output——出口

loader——加载器，加载需要处理的模块，对模块进行转换处理。两个属性：test。use

plugins——定义项目要用的插件

mode——模式development——开发环境，production——生产环境，none

module——决定如果和处理项目中的不同类型的模块

chunk——多个文件组成的一个代码块，例如将一个可执行模块和它所依赖的模块组合成一个chunk

## loader和plugin:

`loader`的单一原则,`loader`只能一件事，比如说`less-loader`,只能解析`less`文件，`plugin`则是针对整个流程执行广泛的任务。监听整个流程的。（webpack.config.js）

### Loader ：

本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

- raw-loader：加载文件原始内容
- file-loader：把文件输出到一个文件夹中，在代码中通过相对url去引用输出的文件
- url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
- image-loader：加载并压缩图片文件
- json-loader：加载json文件
- babel-loader：将es6转成es5
- css-loader：加载css，支持模块化，压缩，文件导入特性
- style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
- eslint-loader：通过 ESLint 检查 JavaScript 代码
- vue-loader：加载vue.js单文件组件

### **Plugin**

就是插件，基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

- `hard-source-webpack-plugin`：为模块提供中间缓存，提高构建速度
- `html-webpack-plugin`：简化 HTML 文件创建 (依赖于 html-loader)
- `ignore-plugin`：忽略部分文件
- `web-webpack-plugin`：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用
- `terser-webpack-plugin`: 支持压缩 ES6 (Webpack4)
- `mini-css-extract-plugin`: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
- `speed-measure-webpack-plugin`: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)
- `webpack-bundle-analyzer`: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)

在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

```js
class MyPlugin {
  apply (compiler) {
    // 找到合适的事件钩子，实现自己的插件功能
    compiler.hooks.emit.tap('MyPlugin', compilation => {
        // compilation: 当前打包构建流程的上下文
        console.log(compilation);
        
        // do something...
    })
  }
}
```

#### 插件及规则配置：

在vue.config.js如果要新增/修改webpack的plugins或者rules，有两种方式：

1. configureWebpack
2. chainWebpack：链式操作 (高级)，接下来所有的配置我都会在该选项中进行配置

#### plugin的修改

plugin参数的修改通过tap去修改

eg：修改打包后css抽离后的filename及抽离所属目录、删除console和debugger

```js
const HotHashWebpackPlugin = require('hot-hash-webpack-plugin');
module.exports = {
    chainWebpack: (config) => {
        // 修改打包时css抽离后的filename及抽离所属目录
        config.plugin('extract-css')
                .tap(args => [{
                    filename: 'css/[name].[contenthash:8].css',
                    chunkFilename: 'css/[name].[contenthash:8].css'
                }]);
        
        // 正式环境下，删除console和debugger
        config.optimization
                .minimize(true)
                .minimizer('terser')
                .tap(args => {
                    let { terserOptions } = args[0];
                    terserOptions.compress.drop_console = true;
                    terserOptions.compress.drop_debugger = true;
                    return args
                });
    }
}
```



## webpack构建流程

1. 初始化：启动构建，读取与合并配置参数，加载Plugin，实例化Compiler
2. 编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理
3. 输出：将编译后的 Module 组合成 Chunk代码块，将 Chunk 转换成文件，输出到文件系统中

## webpack模块打包运行原理

1. 读取webpack的配置参数；
2. 启动webpack，创建Compiler对象并开始解析项目；
3. 从入口文件（entry）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；
4. 对不同文件类型的依赖模块文件使用对应的`Loader`进行编译，最终转为`Javascript`文件；
5. 整个过程中`webpack`会通过发布订阅模式，向外抛出一些`hooks`，而`webpack`的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。



其中文件的解析与构建是一个比较复杂的过程，在`webpack`源码中主要依赖于`compiler`和`compilation`两个核心对象实现。

`compiler`对象是一个全局单例，他负责把控整个`webpack`打包的构建流程。 `compilation`对象是每一次构建的上下文对象，它包含了当次构建所需要的所有信息，每次热更新和重新构建，`compiler`都会重新生成一个新的`compilation`对象，负责此次更新的构建过程。

而每个模块间的依赖关系，则依赖于`AST`语法树。每个模块文件在通过`Loader`解析完成之后，会通过`acorn`库生成模块代码的`AST`语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。

最终`Webpack`打包出来的`bundle`文件是一个`IIFE`的执行函数。webpack5里面只有三个变量和一个方法。`__webpack_modules__`存放了编译后的各个文件模块的JS内容，`__webpack_module_cache__ `用来做模块缓存，`__webpack_exports__`是代码运行的起点，从入口文件开始，启动整个项目。

`__webpack_require__`是`Webpack`内部实现的一套依赖引入函数。在模块化开发的时候，通常会使用`ES Module`或者`CommonJS`规范导出/引入依赖模块，`webpack`打包编译的时候，会统一替换成自己的`__webpack_require__`来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性。

## 文件指纹

文件指纹是打包后输出的文件名的后缀。

`Hash`：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改

`Chunkhash`：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash

`Contenthash`：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变

- JS文件指纹：设置output的filename,用chunkhash

- css文件指纹：设置 MiniCssExtractPlugin 的 filename，使用 contenthash

- 图片文件指纹：

  设置file-loader的name，使用hash。

  占位符名称及含义

  - ext     资源后缀名
  - name    文件名称
  - path    文件的相对路径
  - folder  文件所在的文件夹
  - contenthash   文件的内容hash，默认是md5生成
  - hash         文件内容的hash，默认是md5生成
  - emoji        一个随机的指代文件内容的emoj

```js
module.exports = {
    entry: {
        app: './scr/app.js',
        search: './src/search.js'
    },
    //设置 output 的 filename，用 chunkhash。
    output: {
        filename: '[name][chunkhash:8].js',
        path:__dirname + '/dist'
        //把一个路径或路径片段的序列解析为一个绝对路径
        path: path.resolve(__dirname,'dist')
    },
    //CSS的文件指纹设置
	//设置 MiniCssExtractPlugin 的 filename，使用 contenthash。
    plugins:[
        new MiniCssExtractPlugin({
            filename: `[name][contenthash:8].css`
        })
    ],
    module:{
        rules:[{
            test:/\.(png|svg|jpg|gif)$/,
            use:[{
                loader:'file-loader',
                options:{
                    name:'img/[name][hash:8].[ext]'
                }
            }]
        }]
    }
}
```

## 如何保证各个loader按照预想方式工作？

可以使用 `enforce` 强制执行 `loader` 的作用顺序，`pre` 代表在所有正常 loader 之前执行，`post` 是所有 loader 之后执行。

```js
config.module.rules.push({
        test: /\.ts$/,
        loader: path.join(__dirname, 'conf/lib/lazy-loader.js'),
        enforce: 'pre',
        include: resolve('src/router/config/index.ts'),
        options: {
            // laze-loader需要改写的文件地址
            baseUrl: resolve('src/router/config/index.ts'),
            baseModule: [...getLazyModuleConfig() || []], // 支持配置层面设置，格式:'./auth'
        },
    });
```

## webpack的热更新原理

`Webpack` 的热更新又称热替换（`Hot Module Replacement`），缩写为 `HMR`。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。

HMR的核心就是客户端从服务端拉去更新后的文件，准确的说就是代码块需要更新的部分，实际上 WDS（服务器） 与浏览器之间维护了一个 `Websocket`，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 `Ajax` 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 `jsonp` 请求最新的模块代码。

后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 `HotModulePlugin` 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像`react-hot-loader` 和 `vue-loader` 都是借助这些 API 实现 HMR。

1. **webpack 对文件系统进行 watch ，打包到内存中**文件发生改变后，webpack 重新对文件进行编译打包，然后保存到内存中。
2. **devServer 通知浏览器端文件发生改变**，在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器。webpack-dev-server通过 `_sendStatus` 方法将编译打包后的**新模块 hash 值发送到浏览器端**。
3. **webpack-dev-server/client 接收到服务端消息做出响应**。当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后对应用执行 reload 操作。
4. **webpack 接收到最新 hash 值验证并请求模块代码**。
5. **HotModuleReplacement.runtime 对模块进行热更新**

为什么更新模块的代码不直接在第三步通过 websocket 发送到浏览器端，而是通过 jsonp 来获取呢？我的理解是，功能块的解耦，各个模块各司其职，dev-server/client 只负责消息的传递而不负责新模块的获取，而这些工作应该有 HMR runtime 来完成，HMR runtime 才应该是获取新代码的地方。

## webpack优化

- 使用`高版本`的 Webpack 和 Node.js

- `多进程/多实例构建`：HappyPack(不维护了)、thread-loader

- 压缩代码
  - 多进程并行压缩
    - webpack-paralle-uglify-plugin
    - uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)
    - terser-webpack-plugin 开启 parallel 参数
  - 通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。

- 图片压缩
  - 使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)
  - 配置 image-webpack-loader

- 缩小打包作用域
  - exclude/include (确定 loader 规则范围)
  - resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)
  - resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)
  - resolve.extensions 尽可能减少后缀尝试的可能性
  - noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)
  - IgnorePlugin (完全排除模块)
  - 合理使用alias

- 提取页面公共资源
  - 基础包分离:
    - 使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中
    - 使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件

- DLL
  - 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。
  - HashedModuleIdsPlugin 可以解决模块数字id问题
- 充分利用缓存提升二次构建速度：
  - babel-loader 开启缓存
  - terser-webpack-plugin 开启缓存
  - 使用 cache-loader 或者 hard-source-webpack-plugin

- Tree shaking

  - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率

  - 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking

  - 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码
    - purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)

- Scope hoisting

  - 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突

  - 必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法

- 动态Polyfill
  - 建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)



[[性能优化]Webpack篇](https://www.jianshu.com/p/bbd00d56f625)


Webpack 对图片进行压缩: image-webpack-loader


减少 ES6 转为 ES5 的冗余代码: babel-plugin-transform-runtime


提取公共代码: CommonsChunkPlugin

所有组件的 CSS 提取到同一个文件, 无样式内容闪烁 (fouc): mini-css-extract-plugin
[使用webpack打包编译css文件](https://blog.51cto.com/u_15127667/2785805)

webpack 优化 SourceMap: 
开发环境： 使用内联->更快 eval-source-map
生产环境： 使用外联->减小js文件体积 hidden-source-map

构建结果输出分析: webpack --profile --json > stats.json
[五种可视化方案分析 webpack 打包性能瓶颈](https://juejin.cn/post/6844904056985485320)

[Vue项目Webpack优化实践，构建效率提高50%](https://juejin.cn/post/6844903745810104328)

# vite

## 原理

在生产环境下，Vite使用Rollup来打包。因为rollup基于ESM模块，它是浏览器原生支持的，也就是说我们可以直接在浏览器中去执行`import`，动态引入我们需要的模块，而不是把所有模块打包在一起，比webpack使用的commonjs更高效。并且可以**一次性加载**。可以对源码进行Tree Shaking（去除已经被定义但没被使用的代码）。

Rollup分为**build构建阶段**和output generate**输出生成**阶段。主要过程如下：

- 获取入口文件的内容，包装成module，生成抽象语法树
- 对入口文件抽象语法树进行依赖解析
- 生成最终代码
- 写入目标文件

## esModule和commonJS

`ESM`的执行可以分为三个步骤：

- 构建: 确定从哪里下载该模块文件、下载并将所有的文件解析为模块记录

- 实例化: 将模块记录转换为一个模块实例，为所有的模块分配内存空间，依照导出、导入语句把模块指向对应的内存地址。

- 运行：运行代码，将内存空间填充

`ESM`使用实时绑定的模式，导出和导入的模块都指向相同的内存地址，也就是值引用。而`CJS`采用的是值拷贝，即所有导出值都是拷贝值。

## vite对比webpack

1. 打包过程：

   `Vite`相比于`Webpack`而言，没有打包的过程，而是直接启动了一个开发服务器devServer。`Vite`劫持浏览器的`HTTP`请求，在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器(整个过程没有对文件进行打包编译)。所以编译速度很快。

   `Webpack`在启动时，会先构建项目模块的依赖图，如果在项目中的某个地方改动了代码，`Webpack`则会对相关的依赖重新打包，随着项目的增大，其打包速度也会下降。

2. 热更新：

   `Webpack`: 重新编译，请求变更后模块的代码，客户端重新加载

   `Vite`: 请求变更的模块，再重新加载。

   在热更新的时候，如果某个文件发生了改变，只用对发生变更的模块重新加载，对于没有发生改变的无需重新编译，直接从缓存中获取结果，所以理论上热更新的速度不会变慢。

webpack：**打包**。一旦发生某个依赖，就将这个依赖所处的module更新，并将新的module发送给浏览器重新执行。由于只打了一个bundle.js所以热更新也会重打这个bundle.js.如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢。

vite：**只编译不打包。**Vite对于第三方库使用esbuild预构建依赖，而esbuild是采用go语言编写，因为go语言的操作是纳秒级别，而js是以毫秒计数，所以vite比用js编写的打包器快10-100倍。最终产出的还是分离的分拣，只有编译耗时，当浏览器解析到import的时候，会发起http请求，从而达到不打包也可以加载所需代码的目的。在热更新的时候，如果某个文件发生了改变，只需要更新其本身和用到该文件的文件即可，对于没有发生改变的无需重新编译，直接从缓存中获取结果，所以理论上热更新的速度不会变慢。vite 利用浏览器原生支持模块化导入这一特性，省略了对模块的组装，也就不需要生成 bundle，所以 **冷启动是非常快的**。

webpack 之类的打包工具为了在浏览器里加载各模块，会借助胶水代码用来组装各模块，比如 webpack 使用 map 存放模块 id 和路径，使用 **webpack_require**  方法获取模块导出，vite 利用浏览器原生支持模块化导入这一特性，省略了对模块的组装，也就不需要生成 bundle，所以 **冷启动是非常快的**。

打包工具会将各模块提前打包进 bundle 里，但打包的过程是静态的——不管某个模块的代码是否执行到，这个模块都要打包到 bundle 里，这样的坏处就是随着项目越来越大打包后的 bundle 也越来越大。而 **ESM 天生就是按需加载的，只有 import 的时候才会去按需加载**。

### vite特点：

- 冷服务启动：`No Bundle` + `esbuild` 预构建。没有打包过程，使用模块模式es6的import。

  当我们在浏览器中使用type为module的script标签时，里面的import会被转换为浏览器请求。

  vite就是基于此做了一系列内容，简单讲述下流程

  1. 使用浏览器的es import的能力，拦截当前请求
  2. 获取到当前文件
  3. 根据不同的文件类型，解析对应的文件

  这是vite在文件被访问的时候发生的几件事情，**通过koa的中间件，解析了不同类型的文件**，并生成源码返回给浏览器进行展示，一般就解析一个文件而言，这个速度是非常快的，所以vite在使用的时候会很难感觉到他在解析等待的过程，是一个在毫秒级别的热刷新服务。

  

- 热更新：基于`ESM`的`HMR`，同时利用浏览器缓存策略提升速度

- 按需加载当前页面所需文件，**一个文件一个http请求**，进一步减少启动时间

- 按需进行编译，不会刷新全部dom

- ssr支持

## vite性能优化：

- 预编译：
- 按需编译：
- 客户端强缓存：
- 尽量避免直接处理静态资源：

## vite热更新：

vite在应用启动的时候，会在本地启动两个服务，一个是前端的路径服务，另一个是文件解析的后端服务，两个服务之间使用websocket进行连接。每当页面内容被修改之后，会触发后端服务的文件监听。

- 创建一个`websocket`服务端、`client`文件,并在html中引入，加载ws client文件，启动服务

- vite通过`chokidar`监听文件变更

- 当代码变更后，服务端进行判断，告诉客户端变化类型，变化文件等，并推送到客户端

- 客户端根据推送的信息执行不同操作的更新（根据消息内容决定重新刷新页面还是重新加载变化文件，并执行相关文件注入ws client时设置的hmr hook函数。）

源码分析：

1. 启动热更新：createWebSocketServer

   在vite`dev server`启动前，vite会为HMR做一些准备工作：比如创建`websocket`服务，利用`chokidar`创建一个监听对象 `watcher` 用于对文件修改进行监听。

   `createWebSocketServer`这个方法主是创建`WebSocket`服务并对错误进行一些处理，最后返回封装好的`on`、`off`、 `send` 和 `close` 方法，用于后续服务端推送消息和关闭服务。

2. 执行热更新：

   接收到文件改动执行的回调，这里主要两个操作：`moduleGraph.onFileChange`修改文件的缓存和`handleHMRUpdate`执行热更新。

   - `moduleGraph` 是`Vite`定义的用来记录整个应用的模块依赖图的类，除此之外还有`moduleNode`。`moduleGraph`是由一系列 `map` 组成，而这些`map`分别是`url`、`id`、`file`等与`ModuleNode`的映射，而`ModuleNode` 是 `Vite`中定义的最小模块单位。
   - `handleHMRUpdate` 模块主要是监听文件的更改，进行处理和判断通过`WebSocket`给客户端发送消息通知客户端去请求新的模块代码。

## 基于esbuild的依赖预编译

**为什么需要预构建？**

- 支持`commonJS`依赖

- 上面提到`Vite`是基于浏览器原生支持`ESM`的能力实现的，但要求用户的代码模块必须是`ESM`模块，因此必须将`commonJs`的文件提前处理，转化成 `ESM` 模块并缓存入 `node_modules/.vite`

- 减少模块和请求数量

**为什么使用Esbuild?**

`Esbuild` 则选择使用 `Go` 语言编写，该语言可以编译为原生代码,在编译的时候都将语言转为机器语言，在启动的时候直接执行即可。并且Go天生有多线程的优势。使用esbuild对构建流程进行了优化，充分利用CPU资源。

**执行时机**

`Vite`预编译之后，将文件缓存在`node_modules/.vite/`文件夹下。根据以下地方来决定是否需要重新执行预构建。

- `package.json`中：`dependencies`发生变化

- 包管理器的`lockfile`

如果想强制让`Vite`重新预构建依赖，可以使用`--force`启动开发服务器，或者直接删掉`node_modules/.vite/`文件夹。

# babel原理

Babel 的三个主要处理步骤分别是： **解析（parse）**，**转换（transform）**，**生成（generate）**

- 解析：将代码转换为ast：
  - 词法分析：将代码分割为令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组，每一个 `type` 有一组属性来描述该令牌，和 AST 节点一样它们也有 `start`，`end`，`loc` 属性。
  - 语法分析：分析token流并生成ast
  
- 转换：访问ast的节点进行变换操作生成新的ast，变换操作是指接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。

- 生成：把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建[源码映射（source maps）](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/)

  

# Echarts:

```js
let myChart = echart.init(dom元素)

let option={一些配置项}

myChart.setOption(option);
```



![image-20211210185534685](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211210185534685.png)

![image-20211210191017796](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211210191017796.png)

![image-20220824193628696](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220824193628696.png)

# Git相关命令

![image-20211204213214871](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211204213214871.png)

图中左侧为**工作区**，右侧为版本库。在版本库中标记为 "index" 的区域是**暂存区**（stage/index），标记为 "master" 的是 master 分支所代表的**目录树**。

git restore --staged <文件名>   取消暂存区修改，文件的修改会回到工作区

git reset HEAD   可以将暂存区的所有文件恢复到工作区

git restore <文件名> 将工作区的修改取消

git checkout <文件名>  将工作区的修改取消

### git 解决冲突：

1. 当你commit完代码，push到远程后报如图所示错误，说明你之前已经push过代码了，远程和本地产生冲突

   解决：ggpush -f 强制推送至远程,覆盖之前push的代码

 **git stash**:

能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。



新建代码库：

1. git init 新建代码库
2. git init workspace 新建目录
3. git clone 克隆项目
4. git status 查看仓库当前的状态，显示有变更的文件。

新建分支

1. git branch -a 列出所有本地分支和远程分支
2. git branch guanliping 新建分支，停留在当前分支
3. git checkout -b guanliping 新建并切换到新建的分支
4. git checkout guanliping 切换分支
5. git push origin --delete 删除远程分支

提交代码到远程仓库

1. 在自己的分支将代码添加到暂存区git add .  git commit
2. git status 查看仓库当前的状态，显示有变更的文件。
3. 回到主分支后git pull，更新远程代码
4. 切换到新建分支 git rebase, rebase命令是为了**防止主分支有更新，文件修改冲突**
5. 推送到远程ggpush



git 回退到上次提交

1. git log ：查看并拷贝

2. git reset 提交的id：成功后会撤回 id 的提交，保留提交内容

   git reset --hard 提交的id，成功后会撤回 id 的提交，不保留提交内容

3. git push -f ，此操作会退回到 提交的id 的远程提交之前
    注意：此操作会将最后一次提交到 提交的id 的远程提交中间的所有提交全部退回（退回的提交会清除提交记录），git push -f 之前不要将退回的更改内容提交



git revert和git reset区别：

- git reset ：希望提交的`commit`从历史记录中完全消失就可以用

  使用场景：

  1. 比如你在`master`分支提交了`A-->B-->C`提交了三个记录，这个时候如果C记录有问题你想回滚到B就可以用`git reset`进行
  2. 这个命令大概率的情况都是用在我们主分支的，因为我们上线的分支一般是`master`分支然后从`develop`进行功能开发
  3. 开发完成之后将分支合并到`master`，如果在上线之前发现合并的分支用问题可以将`develop`合并过来的分支进行回滚
  4. 但是有一种情况就是协作开发的时候大家都合并到`master`之后就不能用`reset`强行回滚`commit`因为这样会把其他人的提交记录给冲掉，这时候就可以用`revert`来进行操作

- git revert：

  原理：在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。

  使用场景：

  1. 当你提交了一次commit之后发现提交的可能有问题就可以用到revert；
  2. 已经有很多人提交过代码，但是想改之前的某一次commit记录又不想影响后面的也可以使用revert，他会把你后面提交的记录都放到工作区只是合并的时候需要注意一点。

  `revert`不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。其次`git revert `可以将提交历史中的任何一个提交撤销、而`reset`会把历史上某个提交及之后所有的提交都移除掉。

# TS

## 泛型

- 使用any
  使用any定义时存在的问题：虽然 以 知道传入值的类型但是无法获取函数返回值的类型；另外也失去了ts类型保护的优势

- 使用**泛型**
  泛型指的是在定义函数/接口/类型时，**不预先指定具体的类型，而是在使用的时候在指定类型限制**的一种特性。

  ```js
  // 注意，这里写法是定义的方法哦
  interface Search {
    <T,Y>(name:T,age:Y):T
  }
  
  let fn:Search = function <T, Y>(name: T, id:Y):T {
    console.log(name, id)
    return name;
  }
  fn('li',11);//编译器会自动识别传入的参数，将传入的参数的类型认为是泛型指定的类型
  ```

  







































