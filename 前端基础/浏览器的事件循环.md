# 浏览器的事件循环

## 浏览器基本架构

### 进程与线程

**进程**：进程就是一个程序运行的实例，操作系统会为进程创建独立的内存，用来存放运行所需要的代码和数据

**线程**：线程是进程的组成部分，每个进程至少有一个主线程及可能的若干个子线程，这些线程由所属的进程进行启动管理。线程可以共享操作系统为其所属的同一进程所分配的资源

![](C:\Users\ASUS\Desktop\note\images\前端基础\brower3.png)

**进程和线程的四个特点：**

1. 只要某个线程出错，将会导致整个进程崩溃
2. 进程与进程之间相互隔离。若一个进程挂起或崩溃，并不会影响其他进程的正常运行。进程只能访问系统分配给自己的资源，但可以通过`IPC`机制进行进程间的通信
3. 进程所占用的资源会在其关闭后由操作系统回收。即使进程中存在某个线程产生内存泄漏，当进程退出时，相关的内存资源也会被回收
4. 线程之间可以共享所属进程的数据

### 多进程的浏览器

#### 单进程时代

<img src="C:\Users\ASUS\Desktop\note\images\前端基础\brower2.png" style="zoom:67%;" />

浏览器最初是单进程的，他将所有的功能都运行在同一个进程中，从而导致了安全性，流畅性，稳定性的降低。

* 安全性：由于插件线程的存在，导致了恶意脚本会利用浏览器漏洞来获取系统权限，引发安全问题
* 流畅性：当我们打开一个页面再进行关闭，通常会有内存泄漏的问题，当我们的页面打开次数过多，会导致内存占用过多，致使浏览器运行变慢
* 稳定性：由于所有模块都运行在同一进程中，如果页面某一线程出现崩溃，会导致整个浏览器的崩溃

#### 多进程时代

由于但进程浏览器存在以上问题，所以Chrome推出了多进程浏览器架构，让我们打开浏览器的进程管理看看都有哪些进程吧

<img src="C:\Users\ASUS\Desktop\note\images\前端基础\brower1.png" style="zoom:67%;" />

由上图可以看出浏览器主要有五大进程，分别为：

* 浏览器主进程

  一个浏览器只有一个主进程，负责菜单栏，标题栏等界面显示，文件访问，前进后退，以及子进程管理

* GPU进程

  GPU(图形处理单元)，开启可加速浏览器的渲染

* 插件进程

  主进程为每个加入浏览器的插件开辟独立的子进程。出于安全考虑，这里采用了沙箱模式，在沙箱中运行的程序会受到一些限制，不能读取敏感位置的数据。

* 网络进程

  负责页面网络资源的加载

* 渲染进程

  也称浏览器的内核，我们每打开一个页面浏览器便会开辟一个独立的进程，负责将HTML,CSS,Javasript等资源转为可交换的页面。该进程中包含多个子线程，主要由**Js引擎线程**（我们常说的js是单线程便指的是这个），**GUI渲染线程**，**事件触发线程**，**定时器触发线程**，**异步http请求线程**。当打开一个标签页输入URL后，所发起的网络请求就是从这个进程开始的。

### 单线程的Js

上面说到Js线程是在渲染进程中，但是为什么不将Js设置为多线程呢？

更多是因为其对页面交互的同步处理，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 

举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程。

## 事件循环

### 为什么需要事件循环

上面说了很多关于浏览器方面的知识，是为了让我们更加清楚浏览器为什么需要事件循环（`EventLoop`）？

我们可以想一下`Js`单线程意味着什么？意味着所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。

个人总结为**事件循环主要是为了协调渲染进程中多个线程共同工作，以至可以最大化的利用Cpu。**

### EventLoop

js设计者把任务分为同步任务和异步任务，同步任务都在主线程上排队执行，前面任务没有执行完成，后面的任务会一直等待；异步任务则是挂在在一个任务队列里，等待主线程所有任务执行完成后，通知任务队列可以把可执行的任务放到主线程执行。异步任务放到主线程执行完后，又通知任务队列把下一个异步任务放到主线程中执行。这个过程一直持续，直到异步任务执行完成，这个持续重复的过程就叫Event loop。而一次循环就是一次tick 。

在任务队列中的异步任务又可以分为两种**microtast（微任务）** 和 **macrotask（宏任务）**

* microtast（微任务）：Promise， process.nextTick， Object.observe， MutationObserver

* macrotask（宏任务）：script整体代码、setTimeout、 setInterval等

执行优先级上，**先执行宏任务macrotask，再执行微任务mincrotask**。

执行过程中需要注意的几点是：

- 在一次event loop中，microtask在这一次循环中是一直取一直取，直到清空microtask队列，而macrotask则是一次循环取一次。
- 如果执行事件循环的过程中又加入了异步任务，如果是macrotask，则放到macrotask末尾，等待下一轮循环再执行。如果是microtask，则放到本次event loop中的microtask任务末尾继续执行。直到microtask队列清空。

### 关于async 和 await

**async**

对于async我们只需要了解两点：异步执行和隐式返回Promise。

```javascript
async function foo() {
	return 2
}
console.log(foo())	// Promise {<resolve>: 2}
```

**await**

async函数返回的是一个Promise对象，下面再结合代码看看await到底是什么。

```javascript
async function foo() {
	console.log(1)
	let a = await 100
	console.log(a)
	console.log(2)
}
console.log(0)
foo()
console.log(3)
```

1. 执行console.log(0)语句，打印出来0

2. 执行foo函数，执行console.log(1)语句，打印出来1

3. 下来执行foo函数await语句，这条语句需重点来看，我们把这条语句拆开看看Javascript做了哪些事情

   当执行await 100时，会默认创建一个Promise对象：

   ```javascript
   let promise_ = new Promise((resolve,reject){
     resolve(100)
   })
   ```

   在promise_对象创建过程中，我们可以看到执行函数调用了resolve函数，Javascript会将该任务交给微任务队列。

   Javascript引擎暂停当前协程的执行，将主线程的控制权交给父协程执行，同时将promise_对象返回给父协程。

   主线程的控制权交给父协程后，父协程第一要调用promise_.then来监控promise状态的变化。

4. 接下来继续执行父协程的流程，这里先执行console.log(3)打印3。

5. 父协程进入微任务检查点，执行微任务队列，微任务队列里有resolve(100)的任务等待执行，执行到这里后，会触发promise._then中的回调函数，如下所示：

   ```javascript
   promise_.then((value)=>{
      //回调函数被激活后
     //将主线程控制权交给foo协程，并将vaule值传给协程
   })
   ```

6. 该回调函数被激活后，会将主线程的控制权交给foo函数的协程，并同时将value值传给该协程。

7. foo协程激活之后，会把刚才的value值赋给变量a,然后foo协程继续执行后续语句，执行完后，将控制权归还给父协程。





## 例题讲解

基础知识完毕，我们来看一个例题加深一下理解

```javascript
console.log(1);
setTimeout(function () {
  console.log(2)
}, 0); 
new Promise(function (resolve) {
  console.log(3)    
  for (var i = 100; i > 0; i--) {
    i == 1 && resolve()
  }
  console.log(4)
}).then(function () {
  console.log(5)
}).then(function () {
  console.log(6)
});
console.log(7);
```

先上打印结果：1、3、4、7、5、6、2

* 由于`script`也属于宏任务，所以会开始执行，先**打印1**。
* 遇到setTimeout，将其挂到宏任务队列中，放到下次tick时再执行。
* new Promise在实例的过程中执行代码都是同步进行的，只有回调.then()才是微任务。所以先**打印3**，循环结束后**打印4**。
* 遇到.then,.then，将其放在本次循环的微任务队列中
* **打印7**
* 查询本次循环的微任务队列，**打印5 和 6**
* 本次循环结束，开启下次循环，查找宏任务队列，最后**打印2**

## 参考文章

[通俗易懂的Vue异步更新策略及 nextTick 原理](https://juejin.cn/post/6844904169967452174)

